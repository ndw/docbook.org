<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Publishing DocBook Documents</title><link rel="stylesheet" href="defguide.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.64.1"><link rel="home" href="docbook.html" title="DocBook"><link rel="up" href="part1.html" title="Part&nbsp;I.&nbsp;Introduction"><link rel="previous" href="ch03.html" title="Parsing DocBook Documents"><link rel="next" href="ch05.html" title="Customizing DocBook"></head><body><div class="navheader"><table border="0" cellpadding="0" cellspacing="0" width="100%" summary="Navigation table"><tr><td align="left">&nbsp;<a title="DocBook" href="docbook.html"><img src="figures/nav-home.png" alt="Home" border="0"></a>&nbsp;<a title="Parsing DocBook Documents" href="ch03.html"><img src="figures/nav-prev.png" alt="Prev" border="0"></a>&nbsp;<a title="Part&nbsp;I.&nbsp;Introduction" href="part1.html"><img src="figures/nav-up.png" alt="Up" border="0"></a>&nbsp;<a title="Customizing DocBook" href="ch05.html"><img src="figures/nav-next.png" alt="Next" border="0"></a></td><td align="right"><i>DocBook: The Definitive Guide</i> 2.0.9 <span class="alpha-version">(<a href="co01.html"><em>Alpha</em></a>)</span> </td></tr></table></div><div class="chapter" lang="en"><div class="titlepage"><div><a name="ch-publish"></a><div class="component-title"><h1 class="label">4</h1><h1 class="title">Publishing DocBook Documents</h1></div></div><div><p class="releaseinfo">$Revision: 1.8 $</p></div><div><p class="pubdate">$Date: 2003/06/04 12:32:25 $</p></div><hr class="component-separator"></div><p>
<a class="indexterm" name="publishDocBookch04"></a>
<a class="indexterm" name="DocBookpublishch04"></a>
<a class="indexterm" name="d0e9145"></a>
<a class="indexterm" name="d0e9151"></a>

Creating and editing <span class="acronym">SGML</span>/<span class="acronym">XML</span> documents is usually only half the
battle. After you've composed your document, you'll want to publish
it. Publishing, for our purposes, means either print or web
publishing. For <span class="acronym">SGML</span> and <span class="acronym">XML</span> documents, this is usually
accomplished with some kind of <i class="glossterm">stylesheet</i>.  In
the (not too distant) future, you may be able to publish an <span class="acronym">XML</span>
document on the Web by simply putting it online with a stylesheet, but
for now you'll probably have to translate your document into <span class="acronym">HTML</span>.
</p><p>
<a class="indexterm" name="d0e9180"></a>
<a class="indexterm" name="d0e9186"></a>
<a class="indexterm" name="d0e9190"></a>

There are many ways, using both free and commercial tools, to publish
<span class="acronym">SGML</span> documents. In this chapter, we're going to survey a number of
possibilities, and then look at just one solution in detail: <a href="http://www.jclark.com/jade/" target="_top">Jade</a> and the <a href="http://nwalsh.com/docbook/dsssl/" target="_top">Modular DocBook
Stylesheets.</a> We used jade to produce this
book and to produce the online versions on the
<span class="acronym">CD-ROM</span>; it is also being deployed in other projects
such as <a href="http://www.sgmltools.org/" target="_top"><tt class="literal">&lt;SGML&gt;&amp;tools;</tt>,</a>
which originated with the Linux Documentation Project.
</p><p>
For a brief survey of other tools, see <a href="appd.html" title="Resources">Appendix&nbsp;D, <i>Resources</i></a>.
</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e9215"></a>A Survey of Stylesheet Languages</h2></div></div><div></div></div><p>
<a class="indexterm" name="d0e9220"></a>
<a class="indexterm" name="d0e9226"></a>

Over the years, a number of attempts have been made to produce a
standard stylesheet language and, failing that, a large number of
proprietary languages have been developed.
</p><div class="variablelist"><dl><dt><span class="term">FOSIs</span></dt><dd><p>
<a class="indexterm" name="d0e9239"></a>
<a class="indexterm" name="d0e9243"></a>
<a class="indexterm" name="d0e9249"></a>

First, the U.S. Department of Defense, in an attempt to
standardize stylesheets across military branches, created the
<i class="citetitle">Output Specification</i>, which is defined in
<span class="acronym">MIL-PRF-28001C</span>, <i class="citetitle">Markup Requirements and
Generic Style Specification for Electronic Printed Output and Exchange
of Text</i>.<sup>[<a name="d0e9262" href="#ftn.d0e9262">14</a>]</sup>
</p><p>
<a class="indexterm" name="d0e9272"></a>
<a class="indexterm" name="d0e9276"></a>

Commonly called FOSIs (for Formatting Output Specification Instances),
they are supported by a few products including ADEPT Publisher by
<a href="http://www.arbortext.com/" target="_top">Arbortext</a> and DL
Composer by <a href="http://www.datalogics.com/" target="_top">Datalogics</a>.
</p></dd><dt><span class="term">DSSSL</span></dt><dd><p>
<a class="indexterm" name="d0e9292"></a>
<a class="indexterm" name="d0e9296"></a>
<a class="indexterm" name="d0e9302"></a>
<a class="indexterm" name="d0e9308"></a>

Next, the International Organization for Standardization
(<span class="acronym">ISO</span>) created <span class="acronym">DSSSL</span>, the
Document Style Semantics and Specification Language. Subsets of
<span class="acronym">DSSSL</span> are supported by Jade and a few other tools,
but it never achieved widespread support.
</p></dd><dt><span class="term">CSS</span></dt><dd><p>
<a class="indexterm" name="d0e9329"></a>
<a class="indexterm" name="d0e9333"></a>
<a class="indexterm" name="d0e9339"></a>

The <span class="acronym">W3C</span> CSS Working Group created
<span class="acronym">CSS</span> as a style attachment language for <span class="acronym">HTML</span>, and,
more recently, <span class="acronym">XML</span>.
</p></dd><dt><span class="term">XSL</span></dt><dd><p>
<a class="indexterm" name="d0e9363"></a>
<a class="indexterm" name="d0e9367"></a>
<a class="indexterm" name="d0e9373"></a>
Most recently, the <span class="acronym">XML</span> effort has identified a standard Extensible Style
Language (<span class="acronym">XSL</span>) as a requirement. The
<span class="acronym">W3C</span> <span class="acronym">XSL</span> Working Group is
currently pursuing that effort.
</p></dd></dl></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e9391"></a>Stylesheet Examples</h3></div></div><div></div></div><p>
<a class="indexterm" name="stylsheetsch04"></a>



By way of comparison, here's an example of each of the standard style
languages. In each case, the stylesheet fragment shown contains the
rules that reasonably formatted the following paragraph:
</p><pre class="screen">
&lt;para&gt;
This is an example paragraph. It should be presented in a
reasonable body font. &lt;emphasis&gt;Emphasized&lt;/emphasis&gt; words
should be printed in italics. A single level of 
&lt;emphasis&gt;Nested &lt;emphasis&gt;emphasis&lt;/emphasis&gt; should also
be supported.&lt;/emphasis&gt;
&lt;/para&gt;
</pre><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e9404"></a><span class="acronym">FOSI</span> stylesheet</h4></div></div><div></div></div><p>
<a class="indexterm" name="d0e9411"></a>
<a class="indexterm" name="d0e9417"></a>
<a class="indexterm" name="d0e9423"></a>
<a class="indexterm" name="d0e9427"></a>

<span class="acronym">FOSI</span>s are <span class="acronym">SGML</span> documents. The element in the
<span class="acronym">FOSI</span> that controls the presentation of specific
elements is the <tt class="sgmltag-element">e-i-c</tt> (element in context) element.
A sample <span class="acronym">FOSI</span> fragment is shown in <a href="ch04.html#ex-fosi" title="Example&nbsp;4.1.&nbsp;A Fragment of a FOSI Stylesheet">Example&nbsp;4.1, &#8220;A Fragment of a FOSI Stylesheet&#8221;</a>.
</p><div class="example"><a name="ex-fosi"></a><p class="title"><b>Example&nbsp;4.1.&nbsp;A Fragment of a <span class="acronym">FOSI</span> Stylesheet</b></p><pre class="programlisting">&lt;e-i-c gi="para"&gt;
  &lt;charlist&gt;
    &lt;textbrk startln="1" endln="1"&gt;
  &lt;/charlist&gt;
&lt;/e-i-c&gt;

&lt;e-i-c gi="emphasis"&gt;
  &lt;charlist inherit="1"&gt;
    &lt;font posture="italic"&gt;
  &lt;/charlist&gt;
&lt;/e-i-c&gt;

&lt;e-i-c gi="emphasis" context="emphasis"&gt;
  &lt;charlist inherit="1"&gt;
    &lt;font posture="upright"&gt;
  &lt;/charlist&gt;
&lt;/e-i-c&gt;
</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e9456"></a><span class="acronym">DSSSL</span> stylesheet</h4></div></div><div></div></div><p>
<a class="indexterm" name="d0e9463"></a>
<a class="indexterm" name="d0e9471"></a>

<span class="acronym">DSSSL</span> stylesheets are written in a Scheme-like
language (see <a href="ch04.html#scheme" title="Scheme">the section called &#8220;Scheme&#8221;</a> later in this chapter). It is the
<tt class="function">element</tt> function that controls the presentation of
individual elements. See the example in <a href="ch04.html#ex-dsssl" title="Example&nbsp;4.2.&nbsp;A Fragment of a DSSSL Stylesheet">Example&nbsp;4.2, &#8220;A Fragment of a DSSSL Stylesheet&#8221;</a>.
</p><div class="example"><a name="ex-dsssl"></a><p class="title"><b>Example&nbsp;4.2.&nbsp;A Fragment of a <span class="acronym">DSSSL</span> Stylesheet</b></p><pre class="programlisting">(element para
  (make paragraph
    (process-children)))

(element emphasis
  (make sequence
    font-posture: 'italic
    (process-children)))

(element (emphasis emphasis)
  (make sequence
    font-posture: 'upright
    (process-children)))
</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e9495"></a><span class="acronym">CSS</span> stylesheet</h4></div></div><div></div></div><p>
<a class="indexterm" name="d0e9502"></a>

<span class="acronym">CSS</span> stylesheets consist of selectors and formatting
properties, as shown in <a href="ch04.html#ex-css" title="Example&nbsp;4.3.&nbsp;A Fragment of a CSS Stylesheet">Example&nbsp;4.3, &#8220;A Fragment of a CSS Stylesheet&#8221;</a>.
</p><div class="example"><a name="ex-css"></a><p class="title"><b>Example&nbsp;4.3.&nbsp;A Fragment of a <span class="acronym">CSS</span> Stylesheet</b></p><pre class="programlisting">para              { display: block }
emphasis          { display: inline;
                    font-style: italic; }
emphasis emphasis { display: inline;
                    font-style: upright; }
</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e9521"></a><span class="acronym">XSL</span> stylesheet</h4></div></div><div></div></div><p>
<a class="indexterm" name="d0e9528"></a>

<span class="acronym">XSL</span> stylesheets are <span class="acronym">XML</span> documents, as shown in
<a href="ch04.html#ex-xsl" title="Example&nbsp;4.4.&nbsp;A Fragment of an XSL Stylesheet">Example&nbsp;4.4, &#8220;A Fragment of an XSL Stylesheet&#8221;</a>. The element in the <span class="acronym">XSL</span>
stylesheet that controls the presentation of specific elements is the
<tt class="sgmltag-element">xsl:template</tt> element.
</p><div class="example"><a name="ex-xsl"></a><p class="title"><b>Example&nbsp;4.4.&nbsp;A Fragment of an <span class="acronym">XSL</span> Stylesheet</b></p><pre class="programlisting">&lt;?xml version='1.0'?&gt;
&lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/XSL/Transform/1.0"
                xmlns:fo="http://www.w3.org/XSL/Format/1.0"&gt;

&lt;xsl:template match="para"&gt;   
  &lt;fo:block&gt;
    &lt;xsl:apply-templates/&gt;  
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;  

&lt;xsl:template match="emphasis"&gt;
  &lt;fo:sequence font-style="italic"&gt;
    &lt;xsl:apply-templates/&gt;  
  &lt;/fo:sequence&gt;
&lt;/xsl:template&gt;  

&lt;xsl:template match="emphasis/emphasis"&gt;
  &lt;fo:sequence font-style="upright"&gt;
    &lt;xsl:apply-templates/&gt;  
  &lt;/fo:sequence&gt;
&lt;/xsl:template&gt;  

&lt;/xsl:stylesheet&gt;
</pre></div></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jade"></a>Using Jade and <span class="acronym">DSSSL</span> to Publish DocBook Documents</h2></div></div><div></div></div><p>
<a class="indexterm" name="d0e9564"></a>
<a class="indexterm" name="d0e9570"></a>
<a class="indexterm" name="d0e9576"></a>
<a class="indexterm" name="d0e9582"></a>
<a class="indexterm" name="d0e9590"></a>

Jade is a free tool that applies <a href="http://www.jclark.com/dsssl/" target="_top"> <span class="acronym">DSSSL</span></a>
stylesheets to <span class="acronym">SGML</span> and <span class="acronym">XML</span> documents. As distributed, Jade can
output <span class="acronym">RTF</span>, TeX, <span class="acronym">MIF</span>, and
<span class="acronym">SGML</span>. The <span class="acronym">SGML</span> backend can be used for <span class="acronym">SGML</span> to <span class="acronym">SGML</span>
transformations (for example, DocBook to <span class="acronym">HTML</span>).
</p><p>
A complete set of <span class="acronym">DSSSL</span> stylesheets for creating
print and <span class="acronym">HTML</span> output from DocBook is included on the
<span class="acronym">CD-ROM</span>.  More information about obtaining and
installing Jade appears in <a href="appa.html" title="Installation">Appendix&nbsp;A, <i>Installation</i></a>.
<a class="indexterm" name="d0e9641"></a>
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="dsssl"></a>A Brief Introduction to <span class="acronym">DSSSL</span></h2></div></div><div></div></div><p>
<span class="acronym">DSSSL</span> is a stylesheet language for both print and
online rendering.  The acronym stands for <i class="citetitle">Document Style
Semantics and Specification Language</i>. It is defined by
<span class="acronym">ISO</span>/<span class="acronym">IEC</span> 10179:1996. For more
general information about <span class="acronym">DSSSL</span>, see <a href="http://www.jclark.com/dsssl/" target="_top">the <span class="acronym">DSSSL</span>
Page</a>.
</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="scheme"></a>Scheme</h3></div></div><div></div></div><p>
<a class="indexterm" name="d0e9676"></a>
<a class="indexterm" name="d0e9682"></a>
<a class="indexterm" name="d0e9686"></a>

The <span class="acronym">DSSSL</span> expression language is Scheme, a variant
of Lisp. Lisp is a functional programming language with a remarkably
regular syntax. Every expression looks like this:
<pre class="screen">
(<i class="replaceable"><tt>operator</tt></i> [<span class="optional">arg1</span>] [<span class="optional">arg2</span>] ... [<span class="optional">arg<i class="replaceable"><tt>n</tt></i></span>] )
</pre>
<a class="indexterm" name="d0e9712"></a>
This is called &#8220;<span class="quote">prefix</span>&#8221; syntax because the operator comes
before its arguments.</p><p>In Scheme, the expression that
subtracts 2 from 3, is <tt class="literal">(- 3 2)</tt>. And <tt class="literal">(+ (-
3 2) (* 2 4))</tt> is 9. While the prefix syntax and the
parentheses may take a bit of getting used to, Scheme is not hard to
learn, in part because there are no exceptions to the syntax.
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e9729"></a><span class="acronym">DSSSL</span> Stylesheets</h3></div></div><div></div></div><p>
<a class="indexterm" name="d0e9736"></a>
<a class="indexterm" name="d0e9742"></a>

A complete <span class="acronym">DSSSL</span> stylesheet is shown in <a href="ch04.html#dsssl.stylesheet" title="Example&nbsp;4.5.&nbsp;A Complete DSSSL Stylesheet">Example&nbsp;4.5, &#8220;A Complete DSSSL Stylesheet&#8221;</a>.  After only a brief examination of the
stylesheet, you'll probably begin to have a feel for how it works. For
each element in the document, there is an element rule that describes
how you should format that element. The goal of the rest of this
chapter is to make it possible for you to read, understand, and even
write stylesheets at this level of complexity.
</p><div class="example"><a name="dsssl.stylesheet"></a><p class="title"><b>Example&nbsp;4.5.&nbsp;A Complete <span class="acronym">DSSSL</span> Stylesheet</b></p><pre class="programlisting">&lt;!DOCTYPE style-sheet PUBLIC "-//James Clark//DTD DSSSL Style Sheet//EN"&gt;

&lt;style-sheet&gt;
&lt;style-specification&gt;
&lt;style-specification-body&gt;

(element chapter
  (make simple-page-sequence
    top-margin: 1in
    bottom-margin: 1in
    left-margin: 1in
    right-margin: 1in
    font-size: 12pt
    line-spacing: 14pt
    min-leading: 0pt
    (process-children)))

(element title
  (make paragraph
    font-weight: 'bold
    font-size: 18pt
    (process-children)))

(element para
  (make paragraph
    space-before: 8pt
    (process-children)))

(element emphasis
  (if (equal? (attribute-string "role") "strong")
      (make sequence
	font-weight: 'bold
	(process-children))
      (make sequence
	font-posture: 'italic
	(process-children))))

(element (emphasis emphasis)
  (make sequence
    font-posture: 'upright
    (process-children)))

(define (super-sub-script plus-or-minus
               #!optional (sosofo (process-children)))
  (make sequence
    font-size: (* (inherited-font-size) 0.8)
    position-point-shift: (plus-or-minus (* (inherited-font-size) 0.4))
    sosofo))

(element superscript (super-sub-script +))
(element subscript (super-sub-script -))

&lt;/style-specification-body&gt;
&lt;/style-specification&gt;
&lt;/style-sheet&gt;
</pre></div><p>
<a class="indexterm" name="d0e9763"></a>

This stylesheet is capable of formatting simple DocBook documents like
the one shown in <a href="ch04.html#simple.document" title="Example&nbsp;4.6.&nbsp;A Simple DocBook Document">Example&nbsp;4.6, &#8220;A Simple DocBook Document&#8221;</a>.
</p><div class="example"><a name="simple.document"></a><p class="title"><b>Example&nbsp;4.6.&nbsp;A Simple DocBook Document</b></p><pre class="programlisting">&lt;!DOCTYPE chapter PUBLIC "-//OASIS//DTD Docbook XML V4.1.2//EN"
                  "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd"&gt;
&lt;chapter&gt;&lt;title&gt;Test Chapter&lt;/title&gt;
&lt;para&gt;
This is a paragraph in the test chapter. It is unremarkable in
every regard. This is a paragraph in the test chapter. It is
unremarkable in every regard. This is a paragraph in the test
chapter. It is unremarkable in every regard.
&lt;/para&gt;
&lt;para&gt;
&lt;emphasis role="bold"&gt;This&lt;/emphasis&gt; paragraph contains
&lt;emphasis&gt;some &lt;emphasis&gt;emphasized&lt;/emphasis&gt; text&lt;/emphasis&gt;
and a &lt;superscript&gt;super&lt;/superscript&gt;script
and a &lt;subscript&gt;sub&lt;/subscript&gt;script.
&lt;/para&gt;
&lt;para&gt;
This is a paragraph in the test chapter. It is unremarkable in
every regard. This is a paragraph in the test chapter. It is
unremarkable in every regard. This is a paragraph in the test
chapter. It is unremarkable in every regard.
&lt;/para&gt;
&lt;/chapter&gt;

</pre></div><p>
The result of formatting a simple document with this stylesheet can be
seen in <a href="ch04.html#simple.document.formatted" title="Figure&nbsp;4.1.&nbsp;The formatted simple document">Figure&nbsp;4.1, &#8220;The formatted simple document&#8221;</a>.
</p><div class="figure"><a name="simple.document.formatted"></a><p class="title"><b>Figure&nbsp;4.1.&nbsp;The formatted simple document</b></p><div><img src="figures/simple-page.png" alt="The formatted simple document"></div></div><p>
We'll take a closer look at this stylesheet after you've learned a
little more <span class="acronym">DSSSL</span>.
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e9791"></a><span class="acronym">DSSSL</span> Stylesheets Are <span class="acronym">SGML</span> Documents</h3></div></div><div></div></div><p>
<a class="indexterm" name="d0e9801"></a>
<a class="indexterm" name="d0e9807"></a>
<a class="indexterm" name="d0e9813"></a>

One of the first things that may strike you about
<span class="acronym">DSSSL</span> stylesheets (aside from all the parentheses),
is the fact that the stylesheet itself is an <span class="acronym">SGML</span> document! This
means that you have all the power of <span class="acronym">SGML</span> documents at your disposal
in <span class="acronym">DSSSL</span> stylesheets. In particular, you can use
entities and marked sections to build a modular stylesheet.
</p><p>
<a class="indexterm" name="d0e9833"></a>
<a class="indexterm" name="d0e9839"></a>

In fact, <span class="acronym">DSSSL</span> stylesheets are defined so that they
correspond to a particular <i class="glossterm">architecture</i>. This
means that you can change the <span class="acronym">DTD</span> used by stylesheets within the
bounds of the architecture. A complete discussion of document
architectures is beyond the scope of this book, but we'll show you one
way to take advantage of them in your <span class="acronym">DSSSL</span>
stylesheets in <a href="ch04.html#dsssl.arch" title="The DSSSL Architecture">the section called &#8220;The DSSSL Architecture&#8221;</a> later in the
chapter.
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e9859"></a><span class="acronym">DSSSL</span> Processing Model</h3></div></div><div></div></div><p>
<a class="indexterm" name="d0e9866"></a>
<a class="indexterm" name="d0e9870"></a>
<a class="indexterm" name="d0e9874"></a>

A <span class="acronym">DSSSL</span> processor builds a tree out of the source
document. Each element in the source document becomes a node in the
tree (processing instructions and other constructs become nodes as
well). Processing the source tree begins with the root rule and
continues until there are no more nodes to process.
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e9881"></a>Global Variables and Side Effects</h3></div></div><div></div></div><p>
<a class="indexterm" name="d0e9886"></a>
<a class="indexterm" name="d0e9892"></a>

There aren't any global variables or side effects. It can be difficult
to come to grips with this, especially if you're just starting out.
</p><p>
<a class="indexterm" name="d0e9898"></a>
<a class="indexterm" name="d0e9904"></a>

It is possible to <a href="ch04.html#dsssl.expr.define" title="Define expressions">define constants
and functions</a> and to create local variables with <a href="ch04.html#dsssl.expr.let" title="Let expressions"> <tt class="literal">let</tt> expressions</a>,
but you can't create any global variables or change anything after
you've defined it.
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e9917"></a><span class="acronym">DSSSL</span> Expressions</h3></div></div><div></div></div><p>
<a class="indexterm" name="d0e9924"></a>

<span class="acronym">DSSSL</span> has a rich vocabulary of expressions for
dealing with all of the intricacies of formatting. Many, but by no
means all of them, are supported by Jade. In this introduction, we'll
cover only a few of the most common.
</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="dsssl.expr.element"></a>Element expressions</h4></div></div><div></div></div><p>
<a class="indexterm" name="d0e9936"></a>
<a class="indexterm" name="d0e9944"></a>
<a class="indexterm" name="d0e9950"></a>

Element expressions, which define the rules for formatting particular
elements, make up the bulk of most <span class="acronym">DSSSL</span>
stylesheets. A simple element rule can be seen in <a href="ch04.html#ex.d.simple" title="Example&nbsp;4.7.&nbsp;A Simple DSSSL Rule">Example&nbsp;4.7, &#8220;A Simple DSSSL Rule&#8221;</a>. This rule says that a <a href="para.html"><tt class="sgmltag-element"> para</tt></a>
element should be formatted by making a paragraph (see <a href="ch04.html#dsssl.expr.make" title="Make expressions">the section called &#8220;Make expressions&#8221;</a>).
</p><div class="example"><a name="ex.d.simple"></a><p class="title"><b>Example&nbsp;4.7.&nbsp;A Simple <span class="acronym">DSSSL</span> Rule</b></p><pre class="screen">
(element para
  (make paragraph
    space-before: 8pt
    (process-children)))</pre></div><p>
<a class="indexterm" name="d0e9976"></a>

An element expression can be made more specific by specifying an
element and its ancestors instead of just specifying an element. The
rule <tt class="literal">(element title ...)</tt> applies to all
<a href="title.html"><tt class="sgmltag-element">Title</tt></a> elements, but a rule that begins
<tt class="literal">(element (figure title) ...)</tt> applies only to
<a href="title.html"><tt class="sgmltag-element">Title</tt></a> elements that are immediate children of
<a href="figure.html"><tt class="sgmltag-element">Figure</tt></a> elements.
</p><p>
If several rules apply, the most specific rule is used.
</p><p>
When a rule is used, the node in the source tree that was matched
becomes the &#8220;<span class="quote">current node</span>&#8221; while that element expression
is being processed.
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="dsssl.expr.make"></a>Make expressions</h4></div></div><div></div></div><p>
<a class="indexterm" name="d0e10007"></a>
<a class="indexterm" name="d0e10011"></a>

A make expression specifies the characteristics of a &#8220;<span class="quote">flow
object.</span>&#8221; Flow objects are abstract representations of content
(paragraphs, rules, tables, and so on). The expression:
<pre class="screen">
(make paragraph
  font-size: 12pt
  line-spacing: 14pt ...)
</pre>
specifies that the content that goes &#8220;<span class="quote">here</span>&#8221; is to be
placed into a paragraph flow object with a font-size of 12pt and a
line-spacing of 14pt (all of the unspecified characteristics of the
flow object are defaulted in the appropriate way).
</p><p>
They're called flow objects because <span class="acronym">DSSSL</span>, in its
full generality, allows you to specify the characteristics of a
sequence of flow objects and a set of areas on the physical page where
you can place content. The content of the flow objects is then
&#8220;<span class="quote">poured on to</span>&#8221; (or flows in to) the areas on the page(s).
</p><p>
<a class="indexterm" name="d0e10036"></a>
<a class="indexterm" name="d0e10040"></a>

In most cases, it's sufficient to think of the make expressions as
constructing the flow objects, but they really only specify the
<span class="emphasis"><em>characteristics</em></span> of the flow objects. This detail
is apparent in one of the most common and initially confusing pieces
of <span class="acronym">DSSSL</span> jargon: the
<i class="firstterm">sosofo</i>. Sosofo stands for a
&#8220;<span class="quote">specification of a sequence of flow objects.</span>&#8221; All this
means is that processing a document may result in a nested set of 
<tt class="literal">make</tt> expressions (in other words, the paragraph may contain a table that
contains rows that contain cells that contain paragraphs, and so on).
</p><p>
The general form of a <tt class="literal">make</tt> expression is:
<pre class="screen">
(make <i class="replaceable"><tt>flow-object-name</tt></i>
  <i class="replaceable"><tt>keyword1:</tt></i> <i class="replaceable"><tt>value1</tt></i>
  <i class="replaceable"><tt>keyword2:</tt></i> <i class="replaceable"><tt>value2</tt></i>
  ...
  <i class="replaceable"><tt>keywordn:</tt></i> <i class="replaceable"><tt>valuen</tt></i>
  (<i class="replaceable"><tt>content-expression</tt></i>))
</pre>
</p><p>
<a class="indexterm" name="d0e10093"></a>

Keyword arguments specify the characteristics of the flow object. The
specific characteristics you use depends on the flow object. The
<i class="replaceable"><tt>content-expression</tt></i> can vary; it is usually
another make expression or one of the <a href="ch04.html#dsssl.expr.proc" title="Processing expressions">processing expressions</a>.
</p><p>
<a class="indexterm" name="d0e10107"></a>

Some common flow objects in the print stylesheet are:
</p><div class="variablelist"><dl><dt><span class="term"><tt class="literal">simple-page-sequence</tt></span></dt><dd><p>
<a class="indexterm" name="d0e10119"></a>
Contains a sequence of pages. The keyword arguments of this flow
object let you specify margins, headers and footers, and other
page-related characteristics.  Print stylesheets should always produce
one or more <tt class="literal">simple-page-sequence </tt> flow objects.
</p><p>
Nesting <tt class="literal">simple-page-sequence</tt> does not
work. Characteristics on the inner sequences are ignored.
</p></dd><dt><span class="term"><tt class="literal">paragraph</tt></span></dt><dd><p>
<a class="indexterm" name="d0e10140"></a>
<a class="indexterm" name="d0e10146"></a>

A paragraph is used for any block of text. This may include not only
paragraphs in the source document, but also titles, the terms in a
definition list, glossary entries, and so on. Paragraphs in
<span class="acronym">DSSSL</span> can be nested.
</p></dd><dt><span class="term"><tt class="literal">sequence</tt></span></dt><dd><p>
<a class="indexterm" name="d0e10162"></a>

A sequence is a wrapper. It is most frequently used to change
inherited characteristics (like font style) of a set of flow objects
without introducing other semantics (such as line breaks).
</p></dd><dt><span class="term"><tt class="literal">score</tt></span></dt><dd><p>
<a class="indexterm" name="d0e10175"></a>

A score flow object creates underlining, strike-throughs, or
overlining.
</p></dd><dt><span class="term"><tt class="literal">table</tt></span></dt><dd><p>
<a class="indexterm" name="d0e10186"></a>

A table flow object creates a table of rows and cells.</p></dd></dl></div><p>
<a class="indexterm" name="d0e10194"></a>

The <span class="acronym">HTML</span> stylesheet uses the <span class="acronym">SGML</span> backend, which has a different
selection of flow objects.
</p><div class="variablelist"><dl><dt><span class="term"><tt class="literal">element</tt></span></dt><dd><p>
<a class="indexterm" name="d0e10214"></a>
<a class="indexterm" name="d0e10218"></a>

Creates an element. The content of this <tt class="literal">make</tt>
expression will appear between the start and end tags. The expression:
</p><pre class="screen">
(make element gi: "H1" 
	    (literal "Title"))
</pre><p>produces <tt class="literal">&lt;H1&gt;Title&lt;/H1&gt;</tt>.</p></dd><dt><span class="term"><tt class="literal">empty-element</tt></span></dt><dd><p>
<a class="indexterm" name="d0e10241"></a>
Creates an empty element that may not have content. The expression:</p><pre class="screen">
(make empty-element gi: "BR"
     attributes: '(("CLEAR" "ALL")))
</pre><p>produces <tt class="literal">&lt;BR CLEAR="ALL"&gt;</tt>.</p></dd><dt><span class="term"><tt class="literal">sequence</tt></span></dt><dd><p>
<a class="indexterm" name="d0e10261"></a>

Produces no output in of itself as a wrapper, but is still
required in <span class="acronym">DSSSL</span> contexts in which you want to
output several flow objects but only one object top-level object may
be returned.
</p></dd><dt><span class="term"><tt class="literal">entity-ref</tt></span></dt><dd><p>
<a class="indexterm" name="d0e10277"></a>
<a class="indexterm" name="d0e10283"></a>
<a class="indexterm" name="d0e10289"></a>

Inserts an entity reference. The expression:</p><pre class="screen">(make entity-ref name: "nbsp")</pre><p>produces <tt class="literal">&amp;nbsp;</tt>.</p></dd></dl></div><p>
<a class="indexterm" name="d0e10302"></a>
<a class="indexterm" name="d0e10310"></a>
<a class="indexterm" name="d0e10314"></a>

In both stylesheets, a completely empty flow object is constructed
with <tt class="literal">(empty-sosofo)</tt>.
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="dsssl.expr.data"></a>Selecting data</h4></div></div><div></div></div><p>
<a class="indexterm" name="d0e10328"></a>
<a class="indexterm" name="d0e10332"></a>

Extracting parts of the source document can be accomplished with these
functions:
</p><div class="variablelist"><dl><dt><span class="term"><tt class="literal">(data <i class="replaceable"><tt>nd</tt></i>)</tt></span></dt><dd><p>
Returns all of the character data from <i class="replaceable"><tt>nd</tt></i> as a
string.
</p></dd><dt><span class="term"><tt class="literal">(attribute-string "<i class="replaceable"><tt>attr</tt></i>" <i class="replaceable"><tt>nd</tt></i>)</tt></span></dt><dd><p>
Returns the value of the <i class="replaceable"><tt>attr</tt></i> attribute of <i class="replaceable"><tt>nd</tt></i>.
</p></dd><dt><span class="term"><tt class="literal">(inherited-attribute-string "<i class="replaceable"><tt>attr</tt></i>" <i class="replaceable"><tt>nd</tt></i>)</tt></span></dt><dd><p>
Returns the value of the <i class="replaceable"><tt>attr</tt></i> attribute of
<i class="replaceable"><tt>nd</tt></i>.  If that attribute is not specified on
<i class="replaceable"><tt>nd</tt></i>, it searches up the hierarchy for the first
ancestor element that does set the attribute, and returns its value.
</p></dd></dl></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="dsssl.expr.nodes"></a>Selecting elements</h4></div></div><div></div></div><p>
<a class="indexterm" name="d0e10396"></a>
<a class="indexterm" name="d0e10402"></a>
<a class="indexterm" name="d0e10406"></a>
<a class="indexterm" name="d0e10412"></a>
<a class="indexterm" name="d0e10420"></a>

A common requirement of formatting is the ability to reorder content.
In order to do this, you must be able to select other elements in the
tree for processing. <span class="acronym">DSSSL</span> provides a number of
functions that select other elements.  These functions all return a
list of nodes.
</p><div class="variablelist"><dl><dt><span class="term"><tt class="literal">(current-node)</tt></span></dt><dd><p>Returns the current node.</p></dd><dt><span class="term"><tt class="literal">(children <i class="replaceable"><tt>nd</tt></i>)</tt></span></dt><dd><p>Returns the children of <i class="replaceable"><tt>nd</tt></i>.</p></dd><dt><span class="term"><tt class="literal">(descendants <i class="replaceable"><tt>nd</tt></i>)</tt></span></dt><dd><p>
Returns the descendants of <i class="replaceable"><tt>nd</tt></i> (the children of
<i class="replaceable"><tt>nd</tt></i> and all their children's children, and so on).
</p></dd><dt><span class="term"><tt class="literal">(parent <i class="replaceable"><tt>nd</tt></i>)</tt></span></dt><dd><p>Returns the parent of <i class="replaceable"><tt>nd</tt></i>.</p></dd><dt><span class="term"><tt class="literal">(ancestor "<i class="replaceable"><tt>name</tt></i>" <i class="replaceable"><tt>nd</tt></i>)</tt></span></dt><dd><p>
Returns the first ancestor of <i class="replaceable"><tt>nd</tt></i> named
<i class="replaceable"><tt>name</tt></i>.
</p></dd><dt><span class="term"><tt class="literal">(element-with-id "<i class="replaceable"><tt>id</tt></i>")</tt></span></dt><dd><p>
Returns the element in the document with the <span class="acronym">ID</span>
<i class="replaceable"><tt>id</tt></i>, if such an element exists.
</p></dd><dt><span class="term"><tt class="literal">(select-elements <i class="replaceable"><tt>node-list</tt></i> "<i class="replaceable"><tt>name</tt></i>")</tt></span></dt><dd><p>
Returns all of the elements of the <i class="replaceable"><tt>node-list</tt></i> that have
the name <i class="replaceable"><tt>name</tt></i>. For example, <tt class="literal">(select-elements
(descendants (current-node)) "para")</tt> returns a list of all
the paragraphs that are descendants of the current node.
</p></dd><dt><span class="term"><tt class="literal">(empty-node-list)</tt></span></dt><dd><p>
Returns a node list that contains no nodes.</p></dd></dl></div><p>
Other functions allow you to manipulate node lists.
</p><div class="variablelist"><dl><dt><span class="term"><tt class="literal">(node-list-empty? <i class="replaceable"><tt>nl</tt></i>)</tt></span></dt><dd><p>
Returns true if (and only if) <i class="replaceable"><tt>nl</tt></i> is an empty node
list.
</p></dd><dt><span class="term"><tt class="literal">(node-list-length <i class="replaceable"><tt>nl</tt></i>)</tt></span></dt><dd><p>Returns the number of nodes in <i class="replaceable"><tt>nl</tt></i>.</p></dd><dt><span class="term"><tt class="literal">(node-list-first <i class="replaceable"><tt>nl</tt></i>)</tt></span></dt><dd><p>
Returns a node list that consists of the single node that is the first
node in <i class="replaceable"><tt>nl</tt></i>.
</p></dd><dt><span class="term"><tt class="literal">(node-list-rest <i class="replaceable"><tt>nl</tt></i>)</tt></span></dt><dd><p>
Returns a node list that contains all of the nodes in
<i class="replaceable"><tt>nl</tt></i> except the first node.
</p></dd></dl></div><p>
<a class="indexterm" name="d0e10598"></a>
<a class="indexterm" name="d0e10604"></a>
<a class="indexterm" name="d0e10610"></a>

There are many other expressions for manipulating nodes and node
lists.
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="dsssl.expr.proc"></a>Processing expressions</h4></div></div><div></div></div><p>
<a class="indexterm" name="d0e10621"></a>

Processing expressions control which elements in the document will be
processed and in what order. Processing an element is performed by
finding a matching element rule and using that rule.
</p><div class="variablelist"><dl><dt><span class="term"><tt class="literal">(process-children)</tt></span></dt><dd><p>
Processes all of the children of the current node. In most cases, if
no process expression is given, processing the children is the default
behavior.
</p></dd><dt><span class="term"><tt class="literal">(process-node-list <i class="replaceable"><tt>nl</tt></i>)</tt></span></dt><dd><p>Processes each of the elements in <i class="replaceable"><tt>nl</tt></i>.</p></dd></dl></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="dsssl.expr.define"></a>Define expressions</h4></div></div><div></div></div><p>
<a class="indexterm" name="d0e10651"></a>
<a class="indexterm" name="d0e10657"></a>
<a class="indexterm" name="d0e10661"></a>

You can declare your own functions and constants in
<span class="acronym">DSSSL</span>. The general form of a function declaration
is:
<pre class="screen">
(define (<i class="replaceable"><tt>function</tt></i> <i class="replaceable"><tt>args</tt></i>)
  <i class="replaceable"><tt>function-body</tt></i>)
</pre>
A constant declaration is:
<pre class="screen">(define <i class="replaceable"><tt>constant</tt></i>
  <i class="replaceable"><tt>constant-function-body</tt></i>)
</pre>
</p><p>
The distinction between constants and functions is that the body of a
constant is evaluated when the definition occurs, while functions are
evaluated when they are used.
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="dsssl.expr.conditional"></a>Conditionals</h4></div></div><div></div></div><p>
<a class="indexterm" name="d0e10698"></a>
<a class="indexterm" name="d0e10702"></a>
<a class="indexterm" name="d0e10706"></a>
<a class="indexterm" name="d0e10710"></a>

In <span class="acronym">DSSSL</span>, the constant <tt class="literal">#t</tt>
represents true and <tt class="literal">#f</tt> false. There are several
ways to test conditions and take action in <span class="acronym">DSSSL</span>.
</p><div class="variablelist"><dl><dt><span class="term"><tt class="literal">if</tt></span></dt><dd><p>
<a class="indexterm" name="d0e10736"></a>

The form of an <tt class="literal">if</tt> expression is:
<pre class="screen">
(if <i class="replaceable"><tt>condition</tt></i>
  <i class="replaceable"><tt>true-expression</tt></i>
  <i class="replaceable"><tt>false-expression</tt></i>)
</pre>
</p><p>
If the condition is true, the
<i class="replaceable"><tt>true-expression</tt></i> is evaluated, otherwise the
<i class="replaceable"><tt>false-expression</tt></i> is evaluated. You must
always provide an expression to be evaluated when the condition is not
met. If you want to produce nothing, use
<tt class="literal">(empty-sosofo)</tt>.
</p></dd><dt><span class="term"><tt class="literal">case</tt></span></dt><dd><p>
<a class="indexterm" name="d0e10773"></a>

<tt class="literal">case</tt> selects from among several alternatives:
<pre class="screen">
(case <i class="replaceable"><tt>expression</tt></i>
  ((<i class="replaceable"><tt>constant1</tt></i>) (<i class="replaceable"><tt>expression1</tt></i>)
  ((<i class="replaceable"><tt>constant2</tt></i>) (<i class="replaceable"><tt>expression2</tt></i>)
  ((<i class="replaceable"><tt>constant3</tt></i>) (<i class="replaceable"><tt>expression3</tt></i>)
  (else <i class="replaceable"><tt>else-expression</tt></i>))
</pre>
</p><p>
The value of the expression is compared against each of the constants
in turn and the expression associated with the first matching constant
is evaulated.
</p></dd><dt><span class="term"><tt class="literal">cond</tt></span></dt><dd><p>
<a class="indexterm" name="d0e10816"></a>

<tt class="literal">cond</tt> also selects from among several alternatives,
but the selection is performed by evaluating each expression:
<pre class="screen">
(cond
  ((<i class="replaceable"><tt>condition1</tt></i>) (<i class="replaceable"><tt>expression1</tt></i>)
  ((<i class="replaceable"><tt>condition2</tt></i>) (<i class="replaceable"><tt>expression2</tt></i>)
  ((<i class="replaceable"><tt>condition3</tt></i>) (<i class="replaceable"><tt>expression3</tt></i>)
  (else <i class="replaceable"><tt>else-expression</tt></i>))
</pre>
</p><p>
The value of each conditional is calculated in turn. The expression
associated with the first condition that is true is evaluated.
</p></dd></dl></div><p>
<a class="indexterm" name="d0e10851"></a>

Any expression that returns <tt class="literal">#f</tt> is false; all other
expressions are true. This can be somewhat counterintuitive.  In many
programming languages, it's common to assume that &#8220;<span class="quote">empty</span>&#8221;
things are false (0 is false, a null pointer is false, an empty set is
false, for example.) In <span class="acronym">DSSSL</span>, this isn't the case;
note, for example, that an empty node list is not
<tt class="literal">#f</tt> and is therefore true.  To avoid these
difficulties, always use functions that return true or false in
conditionals. To test for an empty node list, use
<tt class="literal">(node-list-empty?)</tt>.
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="dsssl.expr.let"></a>Let expressions</h4></div></div><div></div></div><p>
<a class="indexterm" name="d0e10875"></a>

The way to create local variables in <span class="acronym">DSSSL</span> is with
<tt class="literal">(let)</tt>. The general form of a <tt class="literal">let</tt>
expression is:
<pre class="screen">
(let ((<i class="replaceable"><tt>var1</tt></i> <span class="abbrev">expression1</span>)
      (<i class="replaceable"><tt>var2</tt></i> <span class="abbrev">expression2</span>)
      ...
      (<i class="replaceable"><tt>varn</tt></i> <span class="abbrev">expressionn</span>))
  <i class="replaceable"><tt>let-body</tt></i>)
</pre>
</p><p>
<a class="indexterm" name="d0e10914"></a>
In a <tt class="literal">let</tt>; expression, all of the variables are
defined &#8220;<span class="quote">simultaneously.</span>&#8221; The expression that defines
<i class="replaceable"><tt> var2</tt></i> cannot contain any references to any
other variables defined in the same <tt class="literal">let</tt>
expression. A <tt class="literal">let*</tt> expression allows variables to
refer to each other, but runs slightly slower.
</p><p>
<a class="indexterm" name="d0e10937"></a>
Variables are available only within the
<i class="replaceable"><tt>let-body</tt></i>.  A common use of
<tt class="literal">let</tt> is within a <tt class="literal">define</tt>
expression:
<pre class="screen">
(define (cals-rule-default nd)
   (let* ((table (ancestor "table" nd))
          (frame (if (attribute-string "frame" table)
                     (attribute-string "frame" table)
                     "all")))
    (equal? frame "all")))
</pre>
</p><p>
This function creates two local variables <tt class="literal">table</tt> and
<tt class="literal">frame</tt>. <tt class="literal">let</tt> returns the value of
the last expression in the body, so this function returns true if the
<tt class="sgmltag-attribute">frame</tt> attribute on the table is
<tt class="literal"> all</tt> or if no <tt class="sgmltag-attribute">frame</tt> attribute is present.
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="dsssl.expr.loop"></a>Loops</h4></div></div><div></div></div><p>
<a class="indexterm" name="d0e10978"></a>
<a class="indexterm" name="d0e10982"></a>
<a class="indexterm" name="d0e10986"></a>

<span class="acronym">DSSSL</span> doesn't have any construct that resembles the
&#8220;<span class="quote">for loop</span>&#8221; that occurs in most imperative languages like C
and Java. Instead, <span class="acronym">DSSSL</span> employs a common trick in
functional languages for implementing a loop: tail recursion.
</p><p>
Loops in <span class="acronym">DSSSL</span> use a special form of
<tt class="literal">let</tt>. This loop counts from 1 to 10:
<pre class="screen">
(let <a name="dl1"></a><img src="figures/callouts/1.png" alt="1" border="0">loopvar <a name="dl2"></a><img src="figures/callouts/2.png" alt="2" border="0">((count 1))
  <a name="dl3"></a><img src="figures/callouts/3.png" alt="3" border="0">(if (&gt; count 10)
    <a name="dl4"></a><img src="figures/callouts/4.png" alt="4" border="0">#t
    (<a name="dl5"></a><img src="figures/callouts/5.png" alt="5" border="0">loopvar <a name="dl6"></a><img src="figures/callouts/6.png" alt="6" border="0">(+ count 1))))</pre></p><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><a href="#dl1"><img src="figures/callouts/1.png" alt="1" border="0"></a> </td><td valign="top" align="left"><p>This variable controls the loop. It is declared without an
initial value, immediately after the <tt class="literal">let</tt>
operand.</p></td></tr><tr><td width="5%" valign="top" align="left"><a href="#dl2"><img src="figures/callouts/2.png" alt="2" border="0"></a> </td><td valign="top" align="left"><p>
<a class="indexterm" name="d0e11031"></a>

Any number of additional local variables can be defined after
the loop variable, just as they can in any other
<tt class="literal">let</tt> expression.</p></td></tr><tr><td width="5%" valign="top" align="left"><a href="#dl3"><img src="figures/callouts/3.png" alt="3" border="0"></a> </td><td valign="top" align="left"><p>If you ever want the loop to end, you have to put some sort of a
test in it.</p></td></tr><tr><td width="5%" valign="top" align="left"><a href="#dl4"><img src="figures/callouts/4.png" alt="4" border="0"></a> </td><td valign="top" align="left"><p>This is the value that will be returned.</p></td></tr><tr><td width="5%" valign="top" align="left"><a href="#dl5"><img src="figures/callouts/5.png" alt="5" border="0"></a> </td><td valign="top" align="left"><p>Note that you iterate the loop by using the loop variable as if
it was a function name.</p></td></tr><tr><td width="5%" valign="top" align="left"><a href="#dl6"><img src="figures/callouts/6.png" alt="6" border="0"></a> </td><td valign="top" align="left"><p>The arguments to this &#8220;<span class="quote">function</span>&#8221; are the values that
you want the local variables declared in <a href="ch04.html#dl2"><img src="figures/callouts/2.png" alt="2" border="0"></a> to have
in the next iteration.</p></td></tr></table></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e11057"></a>A Closer Look at <a href="ch04.html#dsssl.stylesheet" title="Example&nbsp;4.5.&nbsp;A Complete DSSSL Stylesheet">Example&nbsp;4.5, &#8220;A Complete DSSSL Stylesheet&#8221;</a></h3></div></div><div></div></div><p>
<a class="indexterm" name="d0e11063"></a>
<a href="ch04.html#dsssl.stylesheet" title="Example&nbsp;4.5.&nbsp;A Complete DSSSL Stylesheet">Example&nbsp;4.5, &#8220;A Complete DSSSL Stylesheet&#8221;</a> is a style sheet that contains a
style specification. Stylesheets may consist of multiple
specifications, as we'll see in <a href="ch04.html#dsssl.twostylesheets" title="A Single Stylesheet for Both Print and HTML">the section called &#8220;A Single Stylesheet for Both Print and HTML&#8221;</a>.
</p><p>
The actual <span class="acronym">DSSSL</span> code goes in the style
specification body, within the style specification.  Each construction
rule processes different elements from the source document.
</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e11080"></a>Processing chapters</h4></div></div><div></div></div><p>
<a class="indexterm" name="d0e11085"></a>
<a class="indexterm" name="d0e11089"></a>
<a class="indexterm" name="d0e11095"></a>

<a href="chapter.html"><tt class="sgmltag-element">Chapter</tt></a>s are processed by the <tt class="literal">chapter</tt>
construction rule. Each <a href="chapter.html"><tt class="sgmltag-element">Chapter</tt></a> is formatted as a
<tt class="literal">simple-page-sequence</tt>. Every print stylesheet should format
a document as one or more simple page sequences.  Characteristics on
the simple page sequence can specify headers and footers as well as
margins and other page parameters.
</p><p>
<a class="indexterm" name="d0e11115"></a>

One important note about simple page sequences: they cannot nest.
This means that you cannot blindly process divisions
(<a href="part.html"><tt class="sgmltag-element">Part</tt></a>s, <a href="reference.html"><tt class="sgmltag-element">Reference</tt></a>) and the elements they
contain (<a href="chapter.html"><tt class="sgmltag-element">Chapter</tt></a>s, <a href="refentry.html"><tt class="sgmltag-element">RefEntry</tt></a>s) as simple page
sequences. This sometimes involves a little creativity.
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e11133"></a>Processing titles</h4></div></div><div></div></div><p>
<a class="indexterm" name="d0e11138"></a>

The <tt class="literal">make</tt> expression in the <tt class="literal">title</tt> element rule
ensures that <a href="title.html"><tt class="sgmltag-element">Title</tt></a>s are formatted in large, bold print.
</p><p>
This construction rule applies equally to <a href="chapter.html"><tt class="sgmltag-element">Chapter</tt></a> titles,
<a href="figure.html"><tt class="sgmltag-element">Figure</tt></a> titles, and <a href="book.html"><tt class="sgmltag-element">Book</tt></a> titles.  It's unlikely
that you'd want all of these titles to be presented in the same way,
so a more robust stylesheet would have to arrange the processing of
titles with more context.  This might be achieved in the way that
nested <a href="emphasis.html"><tt class="sgmltag-element">Emphasis</tt></a> elements are handled in <a href="ch04.html#dsssl.nestedemph" title="Processing emphasis">the section called &#8220;Processing emphasis&#8221;</a>.
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e11169"></a>Processing paragraphs</h4></div></div><div></div></div><p>
<a href="para.html"><tt class="sgmltag-element">Para</tt></a> elements are simply formatted as paragraphs.
<a class="indexterm" name="d0e11177"></a>

</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="dsssl.nestedemph"></a>Processing emphasis</h4></div></div><div></div></div><p>
<a class="indexterm" name="d0e11188"></a>
<a class="indexterm" name="d0e11194"></a>

Processing <a href="emphasis.html"><tt class="sgmltag-element">Emphasis</tt></a> elements is made a little more
interesting because we want to consider an attribute value and the
possibility that <a href="emphasis.html"><tt class="sgmltag-element">Emphasis</tt></a> elements can be nested.
</p><p>
In the simple case, in which we're processing an <a href="emphasis.html"><tt class="sgmltag-element">Emphasis</tt></a>
element that is not nested, we begin by testing the value of the
<tt class="sgmltag-attribute">role</tt> attribute.  If the content of that
attribute is the string <tt class="literal">strong</tt>, it is formatted
in bold; otherwise, it is formatted in italic.
</p><p>
The nested case is handled by the <tt class="literal">(emphasis emphasis)</tt>
rule. This rule simply formats the content using an upright
(nonitalic) font.  This rule, like the rule for <a href="title.html"><tt class="sgmltag-element">Title</tt></a>s, is
not robust. <a href="emphasis.html"><tt class="sgmltag-element">Emphasis</tt></a> nested inside
<tt class="literal">strong</tt> <a href="emphasis.html"><tt class="sgmltag-element">Emphasis</tt></a> won't be distinguished,
for example, and nestings more than two elements deep will be handled
just as nestings that are two deep.
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e11234"></a>Processing subscripts and superscripts</h4></div></div><div></div></div><p>
<a class="indexterm" name="d0e11239"></a>
<a class="indexterm" name="d0e11245"></a>

Processing <a href="subscript.html"><tt class="sgmltag-element">Subscript</tt></a> and <a href="superscript.html"><tt class="sgmltag-element">Superscript</tt></a> elements
is really handled by the <tt class="literal">super-sub-script</tt> function.
There are several interesting things about this function:
</p><div class="variablelist"><dl><dt><span class="term">The <tt class="literal">plus-or-minus</tt> argument</span></dt><dd><p>
<a class="indexterm" name="d0e11270"></a>
<a class="indexterm" name="d0e11276"></a>

You might ordinarily think of passing a keyword or boolean argument to
the <tt class="function">super-sub-script</tt> function to indicate whether
subscripts or superscripts are desired.  But with Scheme, it's
possible to pass the actual function as an argument!
</p><p>
Note that in the element construction rules for
<a href="superscript.html"><tt class="sgmltag-element">Superscript</tt></a> and <a href="subscript.html"><tt class="sgmltag-element">Subscript</tt></a>, we pass the actual
functions <tt class="literal">+</tt> and <tt class="literal">-</tt>. In the body of
<tt class="function">super-sub-script</tt>, we use the
<tt class="literal">plus-or-minus</tt> argument as a function name (it
appears immediately after an open parenthesis).
</p></dd><dt><span class="term">The optional argument</span></dt><dd><p>
<a class="indexterm" name="d0e11311"></a>

<tt class="literal">optional</tt> arguments are indicated by
<tt class="literal">#!optional</tt> in the function declaration.  Any number of
<tt class="literal">optional</tt> arguments may be given, but each must
specify a default value.  This is accomplished by listing each
argument and default value (an expression) as a pair.
</p><p>
In <tt class="function">super-sub-script</tt>, the optional argument
<tt class="literal">sosofo</tt> is initialized to <tt class="literal">process-children</tt>.
This means that at the point where the function is
<span class="emphasis"><em>called</em></span>, <tt class="literal">process-children</tt> is evaluated and the
resulting <tt class="literal">sosofo</tt> is passed to the function.
</p></dd><dt><span class="term">Use of inherited characteristics</span></dt><dd><p>
<a class="indexterm" name="d0e11350"></a>

It is possible to use the &#8220;<span class="quote">current</span>&#8221; value of an inherited
characteristic to calculate a new value.  Using this technique,
superscripts and subscripts will be presented at 80 percent of the
current font size.
</p></dd></dl></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e11357"></a>Customizing the Stylesheets</h3></div></div><div></div></div><p>
<a class="indexterm" name="d0e11362"></a>
<a class="indexterm" name="d0e11370"></a>
<a class="indexterm" name="d0e11376"></a>

The best way to customize the stylesheets is to write your own
&#8220;<span class="quote">driver</span>&#8221; file; this is a stylesheet that contains your
local modifications and then includes the appropriate stylesheet from
the standard distribution by reference.  This allows you to make local
changes and extensions without modifying the distributed files, which
makes upgrading to the next release much simpler.
</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="dsssl.driver"></a>Writing Your Own Driver</h4></div></div><div></div></div><p>
A basic driver file looks like this:
<pre class="screen">
&lt;!DOCTYPE style-sheet PUBLIC "-//James Clark//DTD DSSSL Style Sheet//EN" [
&lt;!ENTITY dbstyle PUBLIC "-//Norman Walsh//DOCUMENT DocBook Print Stylesheet//EN" CDATA DSSSL&gt;
]&gt;

&lt;style-sheet&gt;
&lt;style-specification use="docbook"&gt;
&lt;style-specification-body&gt;

;; your changes go here...

&lt;/style-specification-body&gt;
&lt;/style-specification&gt;
&lt;external-specification id="docbook" document="dbstyle"&gt;
&lt;/style-sheet&gt;
</pre>
</p><p>
<a class="indexterm" name="d0e11395"></a>
<a class="indexterm" name="d0e11401"></a>

There are two public identifiers associated with the Modular DocBook
Stylesheets:
<div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">-//Norman Walsh//DOCUMENT DocBook Print Stylesheet//EN</tt></p></li><li><p><tt class="literal">-//Norman Walsh//DOCUMENT DocBook HTML Stylesheet//EN</tt></p></li></ul></div>
<a class="indexterm" name="d0e11417"></a>
<a class="indexterm" name="d0e11423"></a>
<a class="indexterm" name="d0e11431"></a>

The former selects the print stylesheet and the latter selects the
<span class="acronym">HTML</span> stylesheet. There is an <span class="acronym">SGML</span> Open catalog file in the
distribution that maps these public identifiers to the stylesheet
files.</p><p>You can add your own definitions, or
redefinitions, of stylesheet rules and parameters so that
<pre class="screen">
;; your changes go here...
</pre>
occurs in the previous example.
</p><p>
<a class="indexterm" name="d0e11450"></a>

For a concrete example of a driver file, see
<tt class="filename">plain.dsl</tt> in the
<tt class="filename">docbook/print</tt> directory in the stylesheet
distribution (or on the <a href="appe.html" title="What's on the CD-ROM?"><span class="acronym">CD-ROM</span></a>).  This is a
customization of the print stylesheet, which turns off title page and
<span class="acronym">TOC</span> generation.
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e11469"></a>Changing the Localization</h4></div></div><div></div></div><p>
<a class="indexterm" name="d0e11474"></a>
<a class="indexterm" name="d0e11482"></a>

As distributed, the stylesheets use English for all generated text,
but other localization files are also provided. The languages supported
at the time of this writing are summarized in
<a href="ch04.html#tbl.lang" title="Table&nbsp;4.1.&nbsp;DocBook Stylesheet Language Codes">Table&nbsp;4.1, &#8220;DocBook Stylesheet Language Codes&#8221;</a>.
(If you can write a localization for another language,
<span class="emphasis"><em>please</em></span> contribute it.)
</p><p>
<a class="indexterm" name="d0e11495"></a>
<a class="indexterm" name="d0e11499"></a>

There are two ways to switch languages: by specifying a <tt class="sgmltag-attribute">lang</tt> attribute, or by changing the
default language in a customization.
</p><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e11510"></a>Using the <tt class="sgmltag-attribute">lang</tt> attribute</h5></div></div><div></div></div><p>
<a class="indexterm" name="d0e11518"></a>
<a class="indexterm" name="d0e11524"></a>

One of the DocBook common attributes is <tt class="sgmltag-attribute">
lang</tt>. If you specify a language, the DocBook stylesheets
will use that language (and all its descendants, if no other language
is specified) for generated text within that element.
</p><p>
<a href="ch04.html#tbl.lang" title="Table&nbsp;4.1.&nbsp;DocBook Stylesheet Language Codes">Table&nbsp;4.1, &#8220;DocBook Stylesheet Language Codes&#8221;</a> summarizes the language codes for the
supported languages.<sup>[<a name="d0e11537" href="#ftn.d0e11537">15</a>]</sup>
<a class="indexterm" name="d0e11547"></a>

The following chapter uses text generated in French:
<pre class="screen">
&lt;chapter lang="fr"&gt;&lt;title&gt;B&ecirc;tises&lt;/title&gt;
&lt;para&gt;Pierre qui roule n'amasse pas de mousse.&lt;/para&gt;
&lt;/chapter&gt;
</pre>
</p><div class="table"><a name="tbl.lang"></a><p class="title"><b>Table&nbsp;4.1.&nbsp;DocBook Stylesheet Language Codes</b></p><table summary="DocBook Stylesheet Language Codes" cellpadding="2px" border="0" style="border-collapse: collapse;"><colgroup><col width="33%"><col width="67%"></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">Language Code</th><th style="border-bottom: 0.5pt solid ; " align="left">Language</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><tt class="literal">af</tt></td><td style="border-bottom: 0.5pt solid ; ">Afrikaans</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><tt class="literal">ca</tt></td><td style="border-bottom: 0.5pt solid ; ">Catalan</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><tt class="literal">cs</tt></td><td style="border-bottom: 0.5pt solid ; ">Czech</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><tt class="literal">da</tt></td><td style="border-bottom: 0.5pt solid ; ">Danish</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><tt class="literal">de</tt></td><td style="border-bottom: 0.5pt solid ; ">German</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><tt class="literal">el</tt></td><td style="border-bottom: 0.5pt solid ; ">Greek</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><tt class="literal">en</tt></td><td style="border-bottom: 0.5pt solid ; ">English</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><tt class="literal">es</tt></td><td style="border-bottom: 0.5pt solid ; ">Spanish</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><tt class="literal">et</tt></td><td style="border-bottom: 0.5pt solid ; ">Estonian</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><tt class="literal">eu</tt></td><td style="border-bottom: 0.5pt solid ; ">Basque</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><tt class="literal">fi</tt></td><td style="border-bottom: 0.5pt solid ; ">Finnish</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><tt class="literal">fr</tt></td><td style="border-bottom: 0.5pt solid ; ">French</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><tt class="literal">he</tt></td><td style="border-bottom: 0.5pt solid ; ">Hebrew</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><tt class="literal">hu</tt></td><td style="border-bottom: 0.5pt solid ; ">Hungarian</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><tt class="literal">id</tt></td><td style="border-bottom: 0.5pt solid ; ">Indonesian</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><tt class="literal">it</tt></td><td style="border-bottom: 0.5pt solid ; ">Italian</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><tt class="literal">ja</tt></td><td style="border-bottom: 0.5pt solid ; ">Japanese</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><tt class="literal">ko</tt></td><td style="border-bottom: 0.5pt solid ; ">Korean</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><tt class="literal">nl</tt></td><td style="border-bottom: 0.5pt solid ; ">Dutch</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><tt class="literal">nn</tt></td><td style="border-bottom: 0.5pt solid ; ">Nyorsk</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><tt class="literal">no</tt></td><td style="border-bottom: 0.5pt solid ; ">Norwegian</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><tt class="literal">pl</tt></td><td style="border-bottom: 0.5pt solid ; ">Polish</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><tt class="literal">pt</tt></td><td style="border-bottom: 0.5pt solid ; ">Portuguese</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><tt class="literal">pt-br</tt></td><td style="border-bottom: 0.5pt solid ; ">Portuguese (Brazil)</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><tt class="literal">ro</tt></td><td style="border-bottom: 0.5pt solid ; ">Romanian</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><tt class="literal">ru</tt></td><td style="border-bottom: 0.5pt solid ; ">Russian</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><tt class="literal">sk</tt></td><td style="border-bottom: 0.5pt solid ; ">Slovak</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><tt class="literal">sl</tt></td><td style="border-bottom: 0.5pt solid ; ">Slovenian</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><tt class="literal">sv</tt></td><td style="border-bottom: 0.5pt solid ; ">Swedish</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><tt class="literal">th</tt></td><td style="border-bottom: 0.5pt solid ; ">Thai</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><tt class="literal">tr</tt></td><td style="border-bottom: 0.5pt solid ; ">Turkish</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><tt class="literal">uk</tt></td><td style="border-bottom: 0.5pt solid ; ">Ukranian</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><tt class="literal">xh</tt></td><td style="border-bottom: 0.5pt solid ; ">Xhosa</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><tt class="literal">zh-cn</tt></td><td style="border-bottom: 0.5pt solid ; ">Chinese (Continental)</td></tr><tr><td style="border-right: 0.5pt solid ; "><tt class="literal">zh-tw</tt></td><td style="">Chinese (Traditional)</td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e11778"></a>Changing the default language</h5></div></div><div></div></div><p>
<a class="indexterm" name="d0e11783"></a>
<a class="indexterm" name="d0e11789"></a>

If no <tt class="sgmltag-attribute">lang</tt> attribute is
specified, the default language is used. You can change the default
language with a <a href="ch04.html#dsssl.driver" title="Writing Your Own Driver">driver</a>.
</p><p>
In the driver, define the default language. <a href="ch04.html#tbl.lang" title="Table&nbsp;4.1.&nbsp;DocBook Stylesheet Language Codes">Table&nbsp;4.1, &#8220;DocBook Stylesheet Language Codes&#8221;</a>
summarizes the language codes for the supported languages. The
following driver makes German the default language:
<pre class="screen">
&lt;!DOCTYPE style-sheet PUBLIC "-//James Clark//DTD DSSSL Style Sheet//EN" [
&lt;!ENTITY dbstyle PUBLIC "-//Norman Walsh//DOCUMENT DocBook Print Stylesheet//EN" CDATA DSSSL&gt;
]&gt;

&lt;style-sheet&gt;
&lt;style-specification use="docbook"&gt;
&lt;style-specification-body&gt;

(define %default-language% "dege")

&lt;/style-specification-body&gt;
&lt;/style-specification&gt;
&lt;external-specification id="docbook" document="dbstyle"&gt;
&lt;/style-sheet&gt;
</pre>
</p><p>
<a class="indexterm" name="d0e11810"></a>

There are two other settings that can be changed only in a driver. Both
of these settings are turned off in the distributed stylesheet:
<div class="variablelist"><dl><dt><span class="term"><tt class="literal">%gentext-language%</tt></span></dt><dd><p>
If a language code is specified in
<tt class="literal">%gentext-language%</tt>, then that language will be used
for all generated text, regardless of any <tt class="sgmltag-attribute">lang</tt> attribute settings in the
document.
</p></dd><dt><span class="term"><tt class="literal">%gentext-use-xref-language%</tt></span></dt><dd><p>
<a class="indexterm" name="d0e11835"></a>
<a class="indexterm" name="d0e11839"></a>

If turned on (defined as <tt class="literal">#t</tt>), then the stylesheets
will generate the text associated with a cross reference using the
language of the target, not the current language. Consider the
following book:
</p><pre class="screen">
&lt;book&gt;&lt;title&gt;A Test Book&lt;/title&gt;
&lt;preface&gt;
&lt;para&gt;There are three chapters in this book: &lt;xref linkend="c1"&gt;, 
&lt;xref linkend="c2"&gt;, and &lt;xref linkend="c3"&gt;.
&lt;/para&gt;
&lt;/preface&gt;
&lt;chapter lang="usen"&gt;&lt;title&gt;English&lt;/title&gt; ... &lt;/chapter&gt;
&lt;chapter lang="fr"&gt;&lt;title&gt;French&lt;/title&gt; ... &lt;/chapter&gt;
&lt;chapter lang="dege"&gt;&lt;title&gt;Deutsch&lt;/title&gt; ... &lt;/chapter&gt;
&lt;/book&gt;
</pre><p>
The standard stylesheets render the Preface as something like this:
</p><div class="blockquote"><blockquote class="blockquote"><p>There are three chapters in this book: Chapter 1, Chapter 2, and Chapter
3.</p></blockquote></div><p>
With <tt class="literal">%gentext-use-xref-language%</tt> turned on, it
would render like this:
</p><div class="blockquote"><blockquote class="blockquote"><p>There are are three chapters in this book: Chapter 1, Chapitre 2, and
Kapitel 3.</p></blockquote></div></dd></dl></div></p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="dsssl.twostylesheets"></a>A Single Stylesheet for Both Print and <span class="acronym">HTML</span></h4></div></div><div></div></div><p>
<a class="indexterm" name="d0e11870"></a>
<a class="indexterm" name="d0e11876"></a>
<a class="indexterm" name="d0e11882"></a>

A <span class="acronym">DSSSL</span> stylesheet consists of one or more
&#8220;<span class="quote">style specifications.</span>&#8221; Using more than one style
specification allows you to build a single stylesheet file that can
format with either the print or <span class="acronym">SGML</span> backends.  <a href="ch04.html#ex-twostyles" title="Example&nbsp;4.8.&nbsp;both.dsl: A Stylesheet with Two Style Specifications">Example&nbsp;4.8, &#8220;both.dsl: A Stylesheet with Two Style Specifications&#8221;</a> shows a stylesheet with two style
specifications.
<a class="indexterm" name="d0e11899"></a>
</p><div class="example"><a name="ex-twostyles"></a><p class="title"><b>Example&nbsp;4.8.&nbsp;<tt class="filename">both.dsl</tt>: A Stylesheet with Two Style Specifications</b></p><pre class="screen">
&lt;!DOCTYPE style-sheet PUBLIC "-//James Clark//DTD DSSSL Style Sheet//EN" [
&lt;!ENTITY html-ss 
  PUBLIC "-//Norman Walsh//DOCUMENT DocBook HTML Stylesheet//EN" CDATA dsssl&gt;
&lt;!ENTITY print-ss
  PUBLIC "-//Norman Walsh//DOCUMENT DocBook Print Stylesheet//EN" CDATA dsssl&gt;
]&gt;
&lt;style-sheet&gt;
&lt;style-specification id="print" use="print-stylesheet"&gt;
&lt;style-specification-body&gt; 

;; customize the print stylesheet

&lt;/style-specification-body&gt;
&lt;/style-specification&gt;
&lt;style-specification id="html" use="html-stylesheet"&gt;
&lt;style-specification-body&gt; 

;; customize the html stylesheet

&lt;/style-specification-body&gt;
&lt;/style-specification&gt;
&lt;external-specification id="print-stylesheet" document="print-ss"&gt;
&lt;external-specification id="html-stylesheet"  document="html-ss"&gt;
&lt;/style-sheet&gt;

</pre></div><p>
<a class="indexterm" name="d0e11918"></a>

Once you have stylesheets with more than one style specification, you
have to be able to indicate which style specification you want to
use. In Jade, you indicate this by providing the <span class="acronym">ID</span>
of the style specification after the stylesheet filename, separated
with a hash mark: <tt class="literal">#</tt>.
</p><p>
Using the code from <a href="ch04.html#ex-twostyles" title="Example&nbsp;4.8.&nbsp;both.dsl: A Stylesheet with Two Style Specifications">Example&nbsp;4.8, &#8220;both.dsl: A Stylesheet with Two Style Specifications&#8221;</a>, you can format a
document using the print stylesheet by running:
</p><pre class="screen">
jade -t rtf -d both.dsl#print file.sgm
</pre><p>
and using the <span class="acronym">HTML</span> stylesheet by running:
</p><pre class="screen">
jade -t sgml -d both.dsl#html file.sgm
</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jademultdecl"></a>Dealing with Multiple Declarations</h3></div></div><div></div></div><p>
<a class="indexterm" name="d0e11948"></a>

The DocBook <span class="acronym">SGML</span> <span class="acronym">DTD</span> and the DocBook <span class="acronym">DSSSL</span>
Stylesheets happen to use the same <span class="acronym">SGML</span> declaration. This makes it
very easy to run Jade with DocBook.  However, you may sometimes wish
to use Jade with other document types, for example the DocBook <span class="acronym">XML</span>
<span class="acronym">DTD</span>, which has a different declaration. There are a couple of ways
to do this.
</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e11972"></a>Pass the Declaration Explicitly</h4></div></div><div></div></div><p>

If your stylesheets parse fine with the default declaration, but you
want to use an alternate declaration with a particular document, just
pass the declaration on the command line:
<pre class="screen">
jade <i class="replaceable"><tt>options</tt></i> the-declaration the-document
</pre>
Note that there's no option required before the declaration; it simply
occurs before the first filename.  Jade concatenates all of the files
that you give it together, and parses them as if they were one
document.
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e11983"></a>Use the Catalogs</h4></div></div><div></div></div><p>
The other way to fix this is with a little catalog trickery.
</p><p>
<a class="indexterm" name="d0e11990"></a>

First, note that Jade always looks in the file called
<tt class="filename">catalog</tt> in the same directory as the document
that it is loading, and uses settings in that file in preference to
settings in other catalogs.
</p><p>
With this fact, we can employ the following trick:
</p><div class="itemizedlist"><ul type="disc"><li><p>Put a <tt class="filename">catalog</tt> file in the directory that
contains your stylesheets, which contain an
<tt class="literal">SGMLDECL</tt> directive.  Jade understands the
directive, which points to the <span class="acronym">SGML</span> declaration that you should use
when parsing the stylesheets. For the DocBook stylesheets, the DocBook
declaration works fine.</p></li><li><p>In the directory that contains the document you want to process,
create a <tt class="filename">catalog</tt> file that contains an
<tt class="literal">SGMLDECL</tt> directive that points to the <span class="acronym">SGML</span>
declaration that should be used when parsing the document.</p></li></ul></div><p>
There's no easy way to have both the stylesheet and the document in
the same directory if they must be processed with different
declarations.  But this is usually not too inconvenient.
</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="dsssl.arch"></a>The <span class="acronym">DSSSL</span> Architecture</h3></div></div><div></div></div><p>
<a class="indexterm" name="d0e12036"></a>
<a class="indexterm" name="d0e12042"></a>
<a class="indexterm" name="d0e12048"></a>
<a class="indexterm" name="d0e12054"></a>

The concept of an architecture was promoted by HyTime. In some ways,
it takes the standard <span class="acronym">SGML</span>/<span class="acronym">XML</span> notions of the role of elements and
attributes and inverts them. Instead of relying on the name of an
element to assign its primary semantics, it uses the values of a small
set of fixed attributes.
</p><p>
While this may be counterintuitive initially, it has an interesting
benefit. An architecture-aware processor can work transparently with
many different <span class="acronym">DTD</span>s. A small example will help illustrate this
point.
</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>The following example demonstrates the concept behind
architectures, but for the sake of simplicity, it does not properly
implement an architecture as defined in HyTime.</p></div><p>
Imagine that you wrote an application that can read an <span class="acronym">SGML</span>/<span class="acronym">XML</span>
document containing a letter (conforming to some letter <span class="acronym">DTD</span>), and
automatically print an envelope for the letter. It's easy to envision
how this works.  The application reads the content of the letter,
extracts the address and return address elements from the source, and
uses them to generate an envelope:
</p><pre class="screen">&lt;?xml version='1.0'&gt;
&lt;!DOCTYPE letter "/share/sgml/letter/letter.dtd" [
&lt;!ENTITY myaddress "/share/sgml/entities/myaddress.xml"&gt;
]&gt;
&lt;letter&gt;
&lt;returnaddress&gt;&amp;myaddress;&lt;/returnaddress&gt;
&lt;address&gt;
&lt;name&gt;Leonard Muellner&lt;/name&gt;
&lt;company&gt;O'Reilly &amp;amp; Associates&lt;/company&gt;
&lt;street&gt;90 Sherman Street&lt;/street&gt;
&lt;city&gt;Cambridge&lt;/city&gt;&lt;state&gt;MA&lt;/state&gt;&lt;zip&gt;02140&lt;/zip&gt;
&lt;/address&gt;
&lt;body&gt;
&lt;salutation&gt;Hi Lenny&lt;/salutation&gt;
...
&lt;/body&gt;</pre><p>
The processor extracts the <tt class="sgmltag-element">Returnaddress</tt> and
<a href="address.html"><tt class="sgmltag-element">Address</tt></a> elements and their children
and prints the envelope accordingly.
</p><p>
Now suppose that a colleague from payroll comes by and asks you to
adapt the application to print envelopes for mailing checks, using the
information in the payroll database, which has a different <span class="acronym">DTD</span>. And
a week later, someone from sales comes by and asks if you can modify
the application to use the contact information <span class="acronym">DTD</span>. After a while,
you would have 11 versions of this program to maintain.
</p><p>
<a class="indexterm" name="d0e12105"></a>

Suppose that instead of using the actual element names to locate the addresses
in the documents, you asked each person to add a few attributes to their <span class="acronym">DTD</span>.
By forcing the attributes to have fixed values, they'd automatically be present
in each document, but authors would never have to worry about them.
</p><p>
For example, the address part of the letter <span class="acronym">DTD</span> might look like
this:
</p><pre class="screen">
&lt;!ELEMENT address (name, company? street*, city, state, zip)&gt;
&lt;!ATTLIST address
	ADDRESS	CDATA	#FIXED "START"
&gt;

&lt;!ELEMENT name (#PCDATA)*&gt;
&lt;!ATTLIST name
	ADDRESS	CDATA	#FIXED "NAME"
&gt;

&lt;!ELEMENT company (#PCDATA)*&gt;
&lt;!ATTLIST company
	ADDRESS	CDATA	#FIXED "COMPANY"
&gt;

&lt;!ELEMENT street (#PCDATA)*&gt;
&lt;!ATTLIST street
	ADDRESS	CDATA	#FIXED "STREET"
&gt;

&lt;!ELEMENT city (#PCDATA)*&gt;
&lt;!ATTLIST city
	ADDRESS	CDATA	#FIXED "CITY"
&gt;

&lt;!ELEMENT state (#PCDATA)*&gt;
&lt;!ATTLIST state
	ADDRESS	CDATA	#FIXED "STATE"
&gt;

&lt;!ELEMENT zip (#PCDATA)*&gt;
&lt;!ATTLIST zip
	ADDRESS	CDATA	#FIXED "ZIP"
&gt;

</pre><p>
Effectively, each address in a letter would look like this:
</p><pre class="screen">
&lt;address ADDRESS="START"&gt;
&lt;name ADDRESS="NAME"&gt;Leonard Muellner&lt;/name&gt;
&lt;company ADDRESS="COMPANY"&gt;O'Reilly &amp;amp;amp; Associates&lt;/company&gt;
&lt;street&gt; ADDRESS="STREET"&gt;90 Sherman Street&lt;/street&gt;
&lt;city ADDRESS="CITY"&gt;Cambridge&lt;/city&gt;&lt;state ADDRESS="STATE"&gt;MA&lt;/state&gt;
&lt;zip ADDRESS="ZIP"&gt;02140&lt;/zip&gt;
&lt;/address&gt;

</pre><p>
In practice, the author would not include the <tt class="sgmltag-attribute">ADDRESS</tt> attributes; they are automatically
provided by the <span class="acronym">DTD</span> because they are
<tt class="literal">#FIXED</tt>.<sup>[<a name="d0e12138" href="#ftn.d0e12138">16</a>]</sup>
</p><p>
Now the address portion of the payroll <span class="acronym">DTD</span> might look like this:
</p><pre class="screen">
&lt;!ELEMENT employee (name, mailingaddress)&gt;

&lt;!ELEMENT name (#PCDATA)*&gt;
&lt;!ATTLIST name
	ADDRESS	CDATA	#FIXED "NAME"
&gt;

&lt;!ELEMENT mailingaddress (addrline1, addrline2, 
                          city, state.or.province, postcode)&gt;
&lt;!ATTLIST mailingaddress
	ADDRESS	CDATA	#FIXED "START"
&gt;

&lt;!ELEMENT addrline1 (#PCDATA)*&gt;
&lt;!ATTLIST addrline1
	ADDRESS	CDATA	#FIXED "STREET"
&gt;

&lt;!ELEMENT addrline2 (#PCDATA)*&gt;
&lt;!ATTLIST addrline2
	ADDRESS	CDATA	#FIXED "STREET"
&gt;

&lt;!ELEMENT city (#PCDATA)*&gt;
&lt;!ATTLIST city
	ADDRESS	CDATA	#FIXED "CITY"
&gt;

&lt;!ELEMENT state.or.province (#PCDATA)*&gt;
&lt;!ATTLIST state.or.province
	ADDRESS	CDATA	#FIXED "STATE"
&gt;

&lt;!ELEMENT postcode (#PCDATA)*&gt;
&lt;!ATTLIST postcode
	ADDRESS	CDATA	#FIXED "ZIP"
&gt;

</pre><p>
The employee records will look like this:
</p><pre class="screen">
&lt;employee&gt;&lt;name ADDRESS="NAME"&gt;Leonard Muellner&lt;/name&gt;
&lt;mailingaddress ADDRESS="START"&gt;
&lt;addrline1 ADDRESS="STREET"&gt;90 Sherman Street&lt;/addrline1&gt;
&lt;city ADDRESS="CITY"&gt;Cambridge&lt;/city&gt;
&lt;state.or.province ADDRESS="STATE"&gt;MA&lt;/state.or.province&gt;
&lt;postcode ADDRESS="ZIP"&gt;02140&lt;/postcode&gt;
&lt;/mailingaddress&gt;
&lt;/employee&gt;

</pre><p>
Your application no longer cares about the actual element names.  It
simply looks for the elements with the correct attributes and uses
them. This is the power of an architecture: it provides a level of
abstraction that processing applications can use to their
advantage. In practice, architectural forms are a bit more complex to
set up because they have facilities for dealing with attribute name
conflicts, among other things.
</p><p>
Why have we told you all this? Because <span class="acronym">DSSSL</span> is an
architecture. This means you can modify the stylesheet <span class="acronym">DTD</span> and still
run your stylesheets through Jade.
</p><p>
Consider the case presented earlier in <a href="ch04.html#ex-twostyles" title="Example&nbsp;4.8.&nbsp;both.dsl: A Stylesheet with Two Style Specifications">Example&nbsp;4.8, &#8220;both.dsl: A Stylesheet with Two Style Specifications&#8221;</a>.
In order to use this stylesheet, you must specify three things: the
backend you want to use, the stylesheet you want to use, and the
style specification you want to use.  If you mismatch any of the
parameters, you'll get the wrong results.  In practice, the problem is
compounded further:
</p><div class="itemizedlist"><ul type="disc"><li><p>Some stylesheets support several backends
(<span class="acronym">RTF</span>, TeX, and <span class="acronym">SGML</span>).
<a class="indexterm" name="d0e12190"></a>
<a class="indexterm" name="d0e12194"></a>

</p></li><li><p>Some stylesheets support only some backends
(<span class="acronym">RTF</span> and <span class="acronym">SGML</span>, but not TeX or
<span class="acronym">MIF</span>).</p></li><li><p>Some stylesheets support multiple outputs using the same
backend (several kinds of <span class="acronym">HTML</span> output, for example, using the
<span class="acronym">SGML</span> backend: <span class="acronym">HTML</span>, <span class="acronym">HTML</span>Help, JavaHelp, and so on).</p></li><li><p>If you have complex stylesheets, some backends may require
additional options to define parameter entities or stylesheet
options.</p></li></ul></div><p>
None of this complexity is really necessary, after all, the options
don't change&#8212;you just have to use the correct combinations. The
mental model is really something like this: &#8220;<span class="quote">I want a certain
kind of output, TeX say, so I have to use this combination of
parameters.</span>&#8221;
</p><p>
You can summarize this information in a table to help keep track of
it:
</p><div class="informaltable"><table border="0" style="border-collapse: collapse;"><colgroup><col width="20%"><col align="center" width="20%"><col width="20%"><col width="20%"><col align="center" width="20%"></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">Desired Output</th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center">Backend</th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">Style specification</th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">Options</th><th style="border-bottom: 0.5pt solid ; " align="center">Supported?</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">rtf</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center">rtf</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">print</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">-V rtf-backend</td><td style="border-bottom: 0.5pt solid ; " align="center">yes</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">tex</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center">tex</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">print</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">-V tex-backend -i tex</td><td style="border-bottom: 0.5pt solid ; " align="center">yes</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">html</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center">sgml</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">htmlweb</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">-i html</td><td style="border-bottom: 0.5pt solid ; " align="center">yes</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">javahelp</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center">sgml</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">help</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">-i help</td><td style="border-bottom: 0.5pt solid ; " align="center">yes</td></tr><tr><td style="border-right: 0.5pt solid ; ">htmlhelp</td><td style="border-right: 0.5pt solid ; " align="center">&nbsp;</td><td style="border-right: 0.5pt solid ; ">&nbsp;</td><td style="border-right: 0.5pt solid ; ">&nbsp;</td><td style="" align="center">no</td></tr></tbody></table></div><p>
Putting this information in a table will help you keep track of it,
but it's not the best solution. The ideal solution is to keep this
information on your system, and let the software figure it all
out. You'd like to be able to run a command, tell it what output you
want from what stylesheet, what file you want to process, and then let
it figure everything else out.  For example:
</p><pre class="screen">
format html mybook.dsl mydoc.sgm
</pre><p>
<a class="indexterm" name="d0e12315"></a>
<a class="indexterm" name="d0e12321"></a>

One way to do this is to put the configuration data in a separate
file, and have the <span><b class="command">format</b></span> command load it out of this other
file.  The disadvantage of this solution is that it introduces another
file that you have to maintain and it's independent from the stylesheet so
it isn't easy to keep it up-to-date.
</p><p>
In the <span class="acronym">DSSSL</span> case, a better alternative is to
modify the stylesheet <span class="acronym">DTD</span> so you can store the configuration
data <span class="emphasis"><em>in the stylesheet</em></span>. Using this alternate <span class="acronym">DTD</span>, your
<tt class="filename">mybook.dsl</tt> stylesheets might look like this:
</p><pre class="screen">
&lt;!DOCTYPE style-sheet 
  PUBLIC "-//Norman Walsh//DTD Annotated DSSSL Style Sheet V1.2//EN" [
&lt;!-- perhaps additional declarations here --&gt;
]&gt;
&lt;style-sheet&gt;
&lt;title&gt;DocBook Stylesheet&lt;/title&gt;
&lt;doctype pubid="-//OASIS//DTD DocBook V3.1//EN"&gt;
&lt;doctype pubid="-//Davenport//DTD DocBook V3.0//EN"&gt;
&lt;doctype pubid="-//Norman Walsh//DTD Website V1.4//EN"&gt;
&lt;backend name="rtf"  backend="rtf"  fragid="print"
         options="-V rtf-backend" default="true"&gt;
&lt;backend name="tex"  backend="tex"  fragid="print"
         options="-V tex-backend -i tex"&gt;
&lt;backend name="html" backend="sgml" fragid="htmlweb" options="-i html"&gt;
&lt;backend name="javahelp" backend="sgml" fragid="help"  options="-i help"&gt;
&lt;backend name="htmlhelp" supported="no"&gt;
&lt;style-specification id="print" use="docbook"&gt;
&lt;style-specification-body&gt;
.
.
.

</pre><p>
In this example, the stylesheet has been annotated with a title, a
list of the public <span class="acronym">ID</span>s to which it is applicable,
and a table that provides information about the output formats that it
supports.
</p><p>
Using this information, the <span><b class="command">format</b></span> command can get all the
information it needs to construct the appropriate call to Jade.  To
make <span class="acronym">HTML</span> from <tt class="filename">myfile.sgm</tt>,
<span><b class="command">format</b></span> would run the following:
</p><pre class="screen">
jade -t sgml -d mybook.dsl#htmlweb -i html myfile.sgm
</pre><p>
The additional information, titles and public <span class="acronym">ID</span>s,
can be used as part of a <span class="acronym">GUI</span> interface to simplify
the selection of stylesheets for an author.
</p><p>
The complete annotated stylesheet <span class="acronym">DTD</span>, and an example of the
<span><b class="command">format</b></span> command script, are provided on <a href="appe.html" title="What's on the CD-ROM?">the <span class="acronym">CD-ROM</span></a>.
<a class="indexterm" name="d0e12391"></a>
<a class="indexterm" name="d0e12393"></a>
</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="xsl"></a>A Brief Introduction to XSL</h2></div><div><div class="author"><h3 class="author"><span class="firstname">Bob</span> <span class="surname">Stayton</span></h3></div></div><div><br clear="all"></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e12409"></a>Using XSL tools to publish DocBook
   documents</h3></div></div><div></div></div><p>There is a growing list of tools to process DocBook
   documents using XSL stylesheets. Each tool implements parts
   or all of the XSL standard, which actually has several
   components:
   <div class="variablelist"><dl><dt><span class="term">Extensible Stylesheet Language (XSL)</span></dt><dd><p>A language for expressing stylesheets written
       in <span class="acronym">XML</span>. It includes the formatting object language, but
       refers to separate documents for the transformation
       language and the path language.</p></dd><dt><span class="term">XSL Transformation (XSLT)</span></dt><dd><p>The part of XSL for transforming <span class="acronym">XML</span> documents
       into other <span class="acronym">XML</span> documents, HTML, or text. It can be used to
       rearrange the content and generate new content.</p></dd><dt><span class="term">XML Path Language (XPath)</span></dt><dd><p>A language for addressing parts of an <span class="acronym">XML</span>
       document. It is used to find the parts of your document to
       apply different styles to. All XSL processors use this
       component.</p></dd></dl></div></p><p>To publish HTML from your <span class="acronym">XML</span> documents, you just
   need an XSLT engine. To get to print, you need an XSLT
   engine to produce formatting objects (FO), which then must
   be processed with a formatting object processor to produce
   PostScript or PDF output.</p><p>James Clark's XT was the first useful XSLT engine,
   and it is still in wide use. It is written in Java, so it
   runs on many platforms, and it is free (
   <a href="http://www.jclark.com" target="_top">http://www.jclark.com</a>).
   XT comes with James Clark's nonvalidating parser XP, but
   you can substitute a different Java parser. Here is a
   simple example of using XT from the Unix command line to
   produce HTML: You'll need to alter your
   <i class="parameter"><tt>CLASSPATH</tt></i> environment variable to
   include the path to where you put the
   <tt class="filename">.jar</tt> files from the XT
   distribution.</p><pre class="screen">CLASSPATH=xt.jar:xp.jar:sax.jar
export CLASSPATH
java  com.jclark.xsl.sax.Driver <i class="replaceable"><tt>filename.xml</tt></i> <i class="replaceable"><tt>docbook/html/docbook.xsl</tt></i> &gt; <i class="replaceable"><tt>output.html</tt></i></pre><p>If you replace the HTML stylesheet with a
   formatting object stylesheet, XT will produce a formatting
   object file. Then you can convert that to PDF using FOP, a
   formatting object processor available for free from the
   Apache <span class="acronym">XML</span> Project (
   <a href="http://xml.apache.org" target="_top">http://xml.apache.org</a>).
   Here is an example of that two stage processing:</p><pre class="screen">CLASSPATH=xt.jar:xp.jar:sax.jar:fop.jar
export CLASSPATH
java  com.jclark.xsl.sax.Driver <i class="replaceable"><tt>filename.xml</tt></i> <i class="replaceable"><tt>docbook/fo/docbook.xsl</tt></i> &gt; <i class="replaceable"><tt>output.fo</tt></i>
java  org.apache.fop.apps.CommandLine <i class="replaceable"><tt>output.fo</tt></i> <i class="replaceable"><tt>output.pdf</tt></i></pre><p>As of this writing, some other XSLT processors to
   choose from include:</p><div class="itemizedlist"><ul type="disc"><li><p>4XSLT, written in Python, from FourThought LLC (
     <a href="http://www.fourthought.com" target="_top">http://www.fourthought.com</a>)</p></li><li><p>Sablotron, written in C++, from Ginger Alliance (

     <a href="http://www.gingerall.com" target="_top">http://www.gingerall.com</a>)</p></li><li><p>Saxon, written in Java, from Michael Kay (
     <a href="http://users.iclway.co.uk/mhkay/saxon" target="_top">http://users.iclway.co.uk/mhkay/saxon</a>)</p></li><li><p>Xalan, written in Java, from the Apache <span class="acronym">XML</span>
     Project (
     <a href="http://xml.apache.org" target="_top">http://xml.apache.org</a>)</p></li><li><p>XML::XSLT,written in Perl, from Geert Josten and
     Egon Willighagen (
     <a href="http://www.cpan.org" target="_top">http://www.cpan.org</a>)</p></li></ul></div><p>For print output, these additional tools are available for processing formatting objects:</p><div class="itemizedlist"><ul type="disc"><li><p>XEP (written in Java) from
   RenderX (
  <a href="http://www.renderx.com" target="_top">http://www.renderx.com</a>).</p></li><li><p>PassiveTeX from Sebastian Rahtz (<a href="http://users.ox.ac.uk/~rahtz/passivetex/" target="_top">http://users.ox.ac.uk/~rahtz/passivetex/</a>).</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e12546"></a>A brief introduction to XSL</h3></div></div><div></div></div><p>XSL is both a transformation language and a
 formatting language. The XSLT transformation part lets you
 scan through a document's structure and rearrange its
 content any way you like. You can write out the content
 using a different set of <span class="acronym">XML</span> tags, and generate text as
 needed. For example, you can scan through a document to
 locate all headings and then insert a generated table of
 contents at the beginning of the document, at the same time
 writing out the content marked up as HTML. XSL is also a
 rich formatting language, letting you apply typesetting
 controls to all components of your output. With a good
 formatting backend, it is capable of producing high quality
 printed pages.</p><p>An XSL stylesheet is written using <span class="acronym">XML</span> syntax, and is
 itself a well-formed <span class="acronym">XML</span> document. That makes the basic
 syntax familiar, and enables an <span class="acronym">XML</span> processor to check for
 basic syntax errors. The stylesheet instructions use
 special element names, which typically begin with
 <tt class="sgmltag-element">xsl:</tt> to distinguish them from any <span class="acronym">XML</span>
 tags you want to appear in the output. The XSL namespace is
 identified at the top of the stylesheet file. As with other
 <span class="acronym">XML</span>, any XSL elements that are not empty will require a
 closing tag. And some XSL elements have specific attributes
 that control their behavior. It helps to keep a good XSL
 reference book handy.</p><p>Here is an example of a simple XSL stylesheet applied
 to a simple <span class="acronym">XML</span> file to generate HTML output.</p><div class="example"><a name="d0e12579"></a><p class="title"><b>Example&nbsp;4.9.&nbsp;Simple <span class="acronym">XML</span> file</b></p><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;document&gt;
&lt;title&gt;Using a mouse&lt;/title&gt;
&lt;para&gt;It's easy to use a mouse. Just roll it
around and click the buttons.&lt;/para&gt;
&lt;/document&gt;</pre></div><div class="example"><a name="d0e12587"></a><p class="title"><b>Example&nbsp;4.10.&nbsp;Simple XSL stylesheet</b></p><pre class="programlisting">&lt;?xml version='1.0'?&gt;
&lt;xsl:stylesheet
          xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version='1.0'&gt;
&lt;xsl:output method="html"/&gt;

&lt;xsl:template match="document"&gt;
  &lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;
    &lt;xsl:value-of select="./title"/&gt;
  &lt;/TITLE&gt;
  &lt;/HEAD&gt;
  &lt;BODY&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/BODY&gt;
  &lt;/HTML&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="title"&gt;
  &lt;H1&gt;&lt;xsl:apply-templates/&gt;&lt;/H1&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="para"&gt;
  &lt;P&gt;&lt;xsl:apply-templates/&gt;&lt;/P&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;
</pre></div><div class="example"><a name="d0e12592"></a><p class="title"><b>Example&nbsp;4.11.&nbsp;HTML output</b></p><pre class="programlisting">&lt;HTML&gt;
&lt;HEAD&gt;
&lt;TITLE&gt;Using a mouse&lt;/TITLE&gt;
&lt;/HEAD&gt;
&lt;BODY&gt;
&lt;H1&gt;Using a mouse&lt;/H1&gt;
&lt;P&gt;It's easy to use a mouse. Just roll it
around and click the buttons.&lt;/P&gt;
&lt;/BODY&gt;
&lt;/HTML&gt;
</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e12597"></a>XSL processing model</h3></div></div><div></div></div><p>XSL is a template language, not a procedural
language. That means a stylesheet specifies a sample of the
output, not a sequence of programming steps to generate it.
A stylesheet consists of a mixture of output samples with
instructions of what to put in each sample. Each bit of
output sample and instructions is called
a  <span class="emphasis"><em>template</em></span>.</p><p>In general, you write a template for each element
type in your document. That lets you concentrate on
handling just one element at a time, and keeps a stylesheet
modular. The power of XSL comes from processing the
templates recursively. That is, each template handles the
processing of its own element, and then calls other
templates to process its children, and so on. Since an <span class="acronym">XML</span>
document is always a single root element at the top level
that contains all of the nested descendent elements, the
XSL templates also start at the top and work their way down
through the hierarchy of elements.</p><p>Take the
DocBook <tt class="sgmltag-element">&lt;para&gt;</tt> paragraph element as
an example. To convert this to HTML, you want to wrap the
paragraph content with the HTML
tags <tt class="sgmltag-starttag">&lt;&lt;p&gt;&gt;</tt> and <tt class="sgmltag-endtag">&lt;/&lt;/p&gt;&gt;</tt>.
But a DocBook <tt class="sgmltag-element">&lt;para&gt;</tt>  can contain
any number of in-line DocBook elements marking up the text.
Fortunately, you can let other templates take care of those
elements, so your XSL template
for <tt class="sgmltag-element">&lt;para&gt;</tt> can be quite
simple:</p><pre class="programlisting">&lt;xsl:template match="para"&gt;
  &lt;p&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/p&gt;
&lt;/xsl:template&gt;
</pre><p>The <tt class="sgmltag-element">&lt;xsl:template&gt;</tt> element
starts a new template, and
its <tt class="sgmltag-attribute">match</tt> attribute indicates where to
apply the template, in this case to
any <tt class="sgmltag-element">&lt;para&gt;</tt> elements. The template
says to output a literal <tt class="sgmltag-starttag">&lt;&lt;p&gt;&gt;</tt> string
and then execute
the <tt class="sgmltag-element">&lt;xsl:apply-templates/&gt;</tt> instruction.
This tells the XSL processor to look among all the
templates in the stylesheet for any that should be applied
to the content of the paragraph. If each template in the
stylesheet includes
an <tt class="sgmltag-element">&lt;xsl:apply-templates/&gt;</tt> instruction,
then all descendents will eventually be processed. When it
is through recursively applying templates to the paragraph
content, it outputs the <tt class="sgmltag-endtag">&lt;/&lt;/p&gt;&gt;</tt> closing
tag.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e12652"></a>Context is important</h4></div></div><div></div></div><p>Since you aren't writing a linear procedure to
process your document, the context of where and how to
apply each modular template is important.
The <tt class="sgmltag-attribute">match</tt> attribute
of <tt class="sgmltag-element">&lt;xsl:template&gt;</tt> provides that
context for most templates. There is an entire expression
language, XPath, for identifying what parts of your
document should be handled by each template. The simplest
context is just an element name, as in the example above.
But you can also specify elements as children of other
elements, elements with certain attribute values, the first
or last elements in a sequence, and so on. Here is how the
DocBook <tt class="sgmltag-element">&lt;formalpara&gt;</tt> element is
handled:</p><pre class="programlisting">&lt;xsl:template match="formalpara"&gt;
  &lt;p&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/p&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="formalpara/title"&gt;
  &lt;b&gt;&lt;xsl:apply-templates/&gt;&lt;/b&gt;
  &lt;xsl:text&gt; &lt;/xsl:text&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="formalpara/para"&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;
</pre><p>There are three templates defined, one for
the <tt class="sgmltag-element">&lt;formalpara&gt;</tt> element itself,
 and one for each of its children elements. The <tt class="sgmltag-attribute">match</tt> attribute
value <tt class="literal">formalpara/title</tt>    in the second
template is an XPath expression indicating
a <tt class="sgmltag-element">&lt;title&gt;</tt> element that is an
immediate child of
a <tt class="sgmltag-element">&lt;formalpara&gt;</tt> element. This
distinguishes such titles from
other <tt class="sgmltag-element">&lt;title&gt;</tt> elements used in
DocBook. XPath expressions are the key to controlling how
your templates are applied.</p><p>In general, the XSL processor has internal rules that
apply templates that are more specific before templates
that are less specific. That lets you control the details,
but also provides a fallback mechanism to a less specific
template when you don't supply the full context for every
combination of elements. This feature is illustrated by the
third template, for <tt class="literal">formalpara/para</tt>. By
including this template, the stylesheet processes a <tt class="sgmltag-element">&lt;para&gt;</tt> within <tt class="sgmltag-element">&lt;formalpara&gt;</tt> in
a special way, in this case by not outputting the HTML <tt class="sgmltag-element">&lt;p&gt;</tt> tags already output by its parent. If this template had not been included, then the processor would have fallen back to the template
specified by <tt class="sgmltag-attribute">match="para"</tt> described
above, which would have output a second set of <tt class="sgmltag-element">&lt;p&gt;</tt> tags.</p><p>You can also control template context with
XSL <span class="emphasis"><em>modes</em></span>, which are used extensively
in the DocBook stylesheets. Modes let you process the same
input more than once in different ways.
A <tt class="sgmltag-attribute">mode</tt> attribute in
an <tt class="sgmltag-element">&lt;xsl:template&gt;</tt> definition adds a
specific mode name to that template. When the same mode
name is used
in <tt class="sgmltag-element">&lt;xsl:apply-templates/&gt;</tt>, it acts
as a filter to narrow the selection of templates to only
those selected by
the <tt class="sgmltag-attribute">match</tt> expression <span class="emphasis"><em>and</em></span> that
have that mode name. This lets you define two different
templates for the same element match that are applied under
different contexts. For example, there are two templates
defined for
DocBook <tt class="sgmltag-element">&lt;listitem&gt;</tt>  elements:</p><pre class="programlisting">&lt;xsl:template match="listitem"&gt;
  &lt;li&gt;&lt;xsl:apply-templates/&gt;&lt;/li&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="listitem" mode="xref"&gt;
  &lt;xsl:number format="1"/&gt;
&lt;/xsl:template&gt;
</pre><p>The first template is for the normal list item
context where you want to output the
HTML <tt class="sgmltag-element">&lt;li&gt;</tt> tags. The second template
is called with <tt class="sgmltag-element">&lt;xsl:apply-templates
select="$target" mode="xref"/&gt;</tt> in the context
of processing <tt class="sgmltag-element">&lt;xref&gt;</tt> elements. In
this case the <tt class="sgmltag-attribute">select</tt> attribute locates
the ID of the specific list item and
the <tt class="sgmltag-attribute">mode</tt> attribute selects the second
template, whose effect is to output its item number when it
is in an ordered list. Because there are many such special
needs when
processing <tt class="sgmltag-element">&lt;xref&gt;</tt> elements, it is
convenient to define a mode name <tt class="literal">xref</tt> to
handle them all. Keep in mind that mode settings
do <span class="emphasis"><em>not</em></span> automatically get passed down to
other templates
through <tt class="sgmltag-element">&lt;xsl:apply-templates/&gt;</tt>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e12762"></a>Programming features</h4></div></div><div></div></div><p>Although XSL is template-driven, it also has some
features of traditional programming languages. Here are
some examples from the DocBook stylesheets. </p><pre class="programlisting"><i class="lineannotation"><span class="lineannotation">Assign a value to a variable:</span></i>
&lt;xsl:variable name="refelem" select="name($target)"/&gt;

<i class="lineannotation"><span class="lineannotation">If statement:</span></i>
&lt;xsl:if test="$show.comments"&gt;
    &lt;i&gt;&lt;xsl:call-template name="inline.charseq"/&gt;&lt;/i&gt;
&lt;/xsl:if&gt;

<i class="lineannotation"><span class="lineannotation">Case statement:</span></i>
&lt;xsl:choose&gt;
    &lt;xsl:when test="@columns"&gt;
        &lt;xsl:value-of select="@columns"/&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:otherwise&gt;1&lt;/xsl:otherwise&gt;
&lt;/xsl:choose&gt;

<i class="lineannotation"><span class="lineannotation">Call a template by name like a subroutine, passing parameter values and accepting a return value:</span></i>
&lt;xsl:call-template name="xref.xreflabel"&gt;
   &lt;xsl:with-param name="target" select="$target"/&gt;
&lt;/xsl:call-template&gt;
</pre><p>However, you can't always use these constructs as you
do in other programming languages. Variables in particular
have very different behavior.</p><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e12782"></a>Using variables and parameters</h5></div></div><div></div></div><p>XSL provides two elements that let you assign a value
to a
name: <tt class="sgmltag-element">&lt;xsl:variable&gt;</tt> and <tt class="sgmltag-element">&lt;xsl:param&gt;</tt>.
These share the same name space and syntax for assigning
names and values. Both can be referred to using
the <tt class="literal">$name</tt> syntax. The main difference
between these two elements is that a param's value acts as
a default value that can be overridden when a template is
called using
a <tt class="sgmltag-element">&lt;xsl:with-param&gt;</tt> element as in the
last example above.</p><p>Here are two examples from DocBook:</p><pre class="programlisting">&lt;xsl:param name="cols"&gt;1&lt;/xsl:param&gt;
&lt;xsl:variable name="segnum" select="position()"/&gt;
</pre><p>In both elements, the name of the parameter or
variable is specified with
the <tt class="sgmltag-attribute">name</tt> attribute. So the name of
the <tt class="sgmltag-element">param</tt> here
is <tt class="sgmltag-attvalue">cols</tt> and the name of
the <tt class="sgmltag-element">variable</tt> is <tt class="sgmltag-attvalue">segnum</tt>.
The value of either can be supplied in two ways. The value
of the first example is the text node "1" and is supplied
as the content of the element. The value of the second
example is supplied as the result of the expression in
its <tt class="sgmltag-attribute">select</tt> attribute, and the element
itself has no content.</p><p>The feature of XSL variables that is odd to new users
is that once you assign a value to a variable, you cannot
assign a new value within the same scope. Doing so will
generate an error. So variables are not used as dynamic
storage bins they way they are in other languages. They
hold a fixed value within their scope of application, and
then disappear when the scope is exited. This feature is a
result of the design of XSL, which is template-driven and
not procedural. This means there is no definite order of
processing, so you can't rely on the values of changing
variables. To use variables in XSL, you need to understand
how their scope is defined.</p><p>Variables defined outside of all templates are
considered global variables, and they are readable within
all templates. The value of a global variable is fixed, and
its global value can't be altered from within any template.
However, a template can create a local variable of the same
name and give it a different value. That local value
remains in effect only within the scope of the local
variable.</p><p>Variables defined within a template remain in effect
only within their permitted scope, which is defined as all
following siblings and their descendants. To understand
such a scope, you have to remember that XSL instructions
are true <span class="acronym">XML</span> elements that are embedded in an <span class="acronym">XML</span> family
hierarchy of XSL elements, often referred to as parents,
children, siblings, ancestors and descendants. Taking the
family analogy a step further, think of a variable
assignment as a piece of advice that you are allowed to
give to certain family members. You can give your advice
only to your younger siblings (those that follow you) and
their descendents. Your older siblings won't listen,
neither will your parents or any of your ancestors. To
stretch the analogy a bit, it is an error to try to give
different advice under the same name to the same group of
listeners (in other words, to redefine the variable). Keep
in mind that this family is not the elements of your
document, but just the XSL instructions in your stylesheet.
To help you keep track of such scopes in hand-written
stylesheets, it helps to indent nested XSL elements. Here
is an edited snippet from the DocBook stylesheet
file <tt class="filename">pi.xsl</tt> that illustrates different
scopes for two variables:</p><pre class="programlisting">
 1 &lt;xsl:template name="dbhtml-attribute"&gt;
 2 ...
 3    &lt;xsl:choose&gt;
 4       &lt;xsl:when test="$count&gt;count($pis)"&gt;
 5          &lt;!-- not found --&gt;
 6       &lt;/xsl:when&gt;
 7       &lt;xsl:otherwise&gt;
 8          &lt;xsl:variable name="pi"&gt;
 9             &lt;xsl:value-of select="$pis[$count]"/&gt;
10          &lt;/xsl:variable&gt;
11          &lt;xsl:choose&gt;
12             &lt;xsl:when test="contains($pi,concat($attribute, '='))"&gt;
13                &lt;xsl:variable name="rest" select="substring-after($pi,concat($attribute,'='))"/&gt;
14                &lt;xsl:variable name="quote" select="substring($rest,1,1)"/&gt;
15                &lt;xsl:value-of select="substring-before(substring($rest,2),$quote)"/&gt;
16             &lt;/xsl:when&gt;
17             &lt;xsl:otherwise&gt;
18             ...
19             &lt;/xsl:otherwise&gt;
20          &lt;/xsl:choose&gt;
21       &lt;/xsl:otherwise&gt;
22    &lt;/xsl:choose&gt;
23 &lt;/xsl:template&gt;

</pre><p>The scope of the variable <tt class="varname">pi</tt> begins
on line 8 where it is defined in this template, and ends on
line 20 when its last sibling ends.<sup>[<a name="d0e12845" href="#ftn.d0e12845">17</a>]</sup>     The scope of the
variable <tt class="varname">rest</tt> begins on line 13 and ends
on line 15. Fortunately, line 15 outputs an expression
using the value before it goes out of scope.</p><p>What happens when
an <tt class="sgmltag-element">&lt;xsl:apply-templates/&gt;</tt> element
is used within the scope of a local variable? Do the
templates that are applied to the document children get the
variable? The answer is no. The templates that are applied
are not actually within the scope of the variable. They
exist elsewhere in the stylesheet and are not following
siblings or their descendants. </p><p>To pass a value to another template, you pass a
parameter using
the <tt class="sgmltag-element">&lt;xsl:with-param&gt;</tt> element. This
parameter passing is usually done with calls to a specific
named template
using <tt class="sgmltag-element">&lt;xsl:call-template&gt;</tt>, although
it works
with <tt class="sgmltag-element">&lt;xsl:apply-templates&gt;</tt> too.
That's because the called template must be expecting the
parameter by defining it using
a <tt class="sgmltag-element">&lt;xsl:param&gt;</tt> element with the same
parameter name. Any passed parameters whose names are not
defined in the called template are ignored.</p><p>Here is an example of parameter passing
from <tt class="filename">docbook.xsl</tt>:</p><pre class="programlisting">&lt;xsl:call-template name="head.content"&gt;
   &lt;xsl:with-param name="node" select="$doc"/&gt;
&lt;/xsl:call-template&gt;
</pre><p>Here a template
named <tt class="literal">head.content</tt> is being called and
passed a parameter named <i class="parameter"><tt>node</tt></i> whose
content is the value of the <tt class="varname">$doc</tt> variable
in the current context. The top of that template looks like
this:</p><pre class="programlisting">&lt;xsl:template name="head.content"&gt;
   &lt;xsl:param name="node" select="."/&gt;
</pre><p>The template is expecting the parameter because it
has a <tt class="sgmltag-element">&lt;xsl:param&gt;</tt> defined with the
same name. The value in this definition is the default
value. This would be the parameter value used in the
template if the template was called without passing that
parameter.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e12899"></a>Generating HTML output.</h4></div></div><div></div></div><p>You generate HTML from your DocBook <span class="acronym">XML</span> files by
applying the HTML version of the stylesheets. This is done
by using the HTML driver
file <tt class="filename">docbook/html/docbook.xsl</tt> as your
stylesheet. That is the master stylesheet file that
uses <tt class="sgmltag-element">&lt;xsl:include&gt;</tt> to pull in the
component files it needs to assemble a complete stylesheet
for producing HTML. </p><p>The way the DocBook stylesheet generates HTML is to
apply templates that output a mix of text content and HTML
elements. Starting at the top level in the main
file <tt class="filename">docbook.xsl</tt>:</p><pre class="programlisting">&lt;xsl:template match="/"&gt;
  &lt;xsl:variable name="doc" select="*[1]"/&gt;
  &lt;html&gt;
  &lt;head&gt;
    &lt;xsl:call-template name="head.content"&gt;
      &lt;xsl:with-param name="node" select="$doc"/&gt;
    &lt;/xsl:call-template&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/body&gt;
  &lt;/html&gt;
&lt;/xsl:template&gt;
</pre><p>This template matches the root element of your input
document, and starts the process of recursively applying
templates. It first defines a variable
named <tt class="varname">doc</tt> and then outputs two literal
HTML elements <tt class="sgmltag-element">&lt;html&gt;</tt> and <tt class="sgmltag-element">&lt;head&gt;</tt>.
Then it calls a named
template <tt class="literal">head.content</tt> to process the
content of the HTML <tt class="sgmltag-element">&lt;head&gt;</tt>, closes
the <tt class="sgmltag-element">&lt;head&gt;</tt> and starts
the <tt class="sgmltag-element">&lt;body&gt;</tt>. There it
uses <tt class="sgmltag-emptytag">&lt;&lt;xsl:apply-templates/&gt;/&gt;</tt> to
recursively process the entire input document. Then it just
closes out the HTML file.</p><p>Simple HTML elements can generated as literal
elements as shown here. But if the HTML being output
depends on the context, you need something more powerful to
select the element name and possibly add attributes and
their values. Here is a fragment
from <tt class="filename">sections.xsl</tt> that shows how a
heading tag is generated using
the <tt class="sgmltag-element">&lt;xsl:element&gt;</tt> and <tt class="sgmltag-element">&lt;xsl:attribute&gt;</tt> elements:</p><pre class="programlisting">
 1 &lt;xsl:element name="h{$level}"&gt;
 2   &lt;xsl:attribute name="class"&gt;title&lt;/xsl:attribute&gt;
 3   &lt;xsl:if test="$level&lt;3"&gt;
 4     &lt;xsl:attribute name="style"&gt;clear: all&lt;/xsl:attribute&gt;
 5   &lt;/xsl:if&gt;
 6   &lt;a&gt;
 7     &lt;xsl:attribute name="name"&gt;
 8       &lt;xsl:call-template name="object.id"/&gt;
 9     &lt;/xsl:attribute&gt;
10     &lt;b&gt;&lt;xsl:copy-of select="$title"/&gt;&lt;/b&gt;
11   &lt;/a&gt;
12 &lt;/xsl:element&gt;
</pre><p>This whole example is generating a single HTML
heading element. Line 1 begins the HTML element definition
by identifying the name of the element. In this case, the
name is an expression that includes the
variable <i class="parameter"><tt>$level</tt></i> passed as a parameter to
this template. Thus a single template can
generate <tt class="sgmltag-element">&lt;h1&gt;</tt>, <tt class="sgmltag-element">&lt;h2&gt;</tt>,
etc. depending on the context in which it is called. Line 2
defines a <tt class="sgmltag-attribute">class="title"</tt> attribute that is
added to this element. Lines 3 to 5 add
a <tt class="sgmltag-attribute">style="clear all"</tt> attribute, but only
if the heading level is less than 3. Line 6 opens
an <tt class="sgmltag-element">&lt;a&gt;</tt> anchor element. Although this
looks like a literal output string, it is actually modified
by lines 7 to 9 that insert
the <tt class="sgmltag-attribute">name</tt> attribute into
the <tt class="sgmltag-element">&lt;a&gt;</tt> element. This illustrates
that XSL is managing output elements as active element
nodes, not just text strings. Line 10 outputs the text of
the heading title, also passed as a parameter to the
template, enclosed in HTML boldface tags. Line 11 closes
the anchor tag with the
literal <tt class="sgmltag-endtag">&lt;/&lt;/a&gt;&gt;</tt> syntax, while line 12
closes the heading tag by closing the element definition.
Since the actual element name is a variable, it couldn't
use the literal syntax.</p><p>As you follow the sequence of nested templates
processing elements, you might be wondering how the
ordinary text of your input document gets to the output. In
the file <tt class="filename">docbook.xsl</tt> you will find
this template that handles any text not processed by any
other template:</p><pre class="programlisting">&lt;xsl:template match="text()"&gt;
  &lt;xsl:value-of select="."/&gt;
&lt;/xsl:template&gt;
</pre><p>This template's body consists of the "value" of the text node,
which is just its text. In general, all XSL processors have
some built-in templates to handle any content for which
your stylesheet doesn't supply a matching template. This
template serves the same function but appears explicitly in
the stylesheet.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e12997"></a>Generating formatting objects.</h4></div></div><div></div></div><p>You generate formatting objects from your DocBook <span class="acronym">XML</span>
files by applying the fo version of the stylesheets. This
is done by using the fo driver
file <tt class="filename">docbook/fo/docbook.xsl</tt> as your
stylesheet. That is the master stylesheet file that
uses <tt class="sgmltag-element">&lt;xsl:include&gt;</tt> to pull in the
component files it needs to assemble a complete stylesheet
for producing formatting objects. Generating a formatting
objects file is only half the process of producing typeset
output. You also need a formatting object processor such as
the Apache <span class="acronym">XML</span> Project's FOP as described in an earlier
section.</p><p>The DocBook fo stylesheet works in a similar manner
to the HTML stylesheet. Instead of outputting HTML tags, it
outputs text marked up
with <tt class="sgmltag-element">&lt;fo:<i class="replaceable"><tt>something</tt></i>&gt;</tt> tags.
For example, to indicate that some text should be kept
in-line and typeset with a monospace font, it might look
like this:</p><pre class="programlisting">&lt;fo:inline-sequence font-family="monospace"&gt;/usr/man&lt;/fo:inline-sequence&gt;</pre><p>The templates
in <tt class="filename">docbook/fo/inline.xsl</tt>      that produce
this output for a
DocBook   <tt class="sgmltag-element">&lt;filename&gt;</tt>     element look
like this:</p><pre class="programlisting">&lt;xsl:template match="filename"&gt;
  &lt;xsl:call-template name="inline.monoseq"/&gt;
&lt;/xsl:template&gt;

&lt;xsl:template name="inline.monoseq"&gt;
  &lt;xsl:param name="content"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/xsl:param&gt;
  &lt;fo:inline-sequence font-family="monospace"&gt;
    &lt;xsl:copy-of select="$content"/&gt;
  &lt;/fo:inline-sequence&gt;
&lt;/xsl:template&gt;
</pre><p>There are dozens of fo tags and attributes specified
in the XSL standard. It is beyond the scope of this
document to cover how all of them are used in the DocBook
stylesheets. Fortunately, this is only an intermediate
format that you probably won't have to deal with very much
directly unless you are writing your own
stylesheets.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e13036"></a>Customizing DocBook XSL stylesheets</h3></div></div><div></div></div><p>The DocBook XSL stylesheets are written in a modular
fashion. Each of the HTML and FO stylesheets starts with a
driver file that assembles a collection of component files
into a complete stylesheet. This modular design puts similar things together into smaller files that are easier to write and maintain than one big stylesheet. The modular stylesheet files
are distributed among four directories:</p><div class="variablelist"><dl><dt><span class="term">common/</span></dt><dd><p>contains code common to both stylesheets, including localization data
</p></dd><dt><span class="term">fo/</span></dt><dd><p>a stylesheet that produces XSL FO result trees
</p></dd><dt><span class="term">html/</span></dt><dd><p>a stylesheet that produces HTML/XHTML result trees
</p></dd><dt><span class="term">lib/</span></dt><dd><p>contains schema-independent functions
</p></dd></dl></div><p>The driver files for each of HTML and FO stylesheets
are <tt class="filename">html/docbook.xsl</tt> and <tt class="filename">fo/docbook.xsl</tt>,
respectively. A driver file consists mostly of a bunch
of <tt class="sgmltag-element">&lt;xsl:include&gt;</tt> instructions to
pull in the component templates, and then defines some
top-level templates. For example:</p><pre class="programlisting">&lt;xsl:include href="../VERSION"/&gt;
&lt;xsl:include href="../lib/lib.xsl"/&gt;
&lt;xsl:include href="../common/l10n.xsl"/&gt;
&lt;xsl:include href="../common/common.xsl"/&gt;
&lt;xsl:include href="autotoc.xsl"/&gt;
&lt;xsl:include href="lists.xsl"/&gt;
&lt;xsl:include href="callout.xsl"/&gt;
...
&lt;xsl:include href="param.xsl"/&gt;
&lt;xsl:include href="pi.xsl"/&gt;
</pre><p>The first four modules are shared with the FO
stylesheet and are referenced using relative pathnames to
the common directories. Then the long list of component
stylesheets starts. Pathnames in include statements are
always taken to be relative to the including file. Each
included file must be a valid XSL stylesheet, which means
its root element must
be <tt class="sgmltag-element">&lt;xsl:stylesheet&gt;</tt>.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e13084"></a>Stylesheet inclusion vs. importing</h4></div></div><div></div></div><p>XSL actually provides two inclusion
mechanisms: <tt class="sgmltag-element">&lt;xsl:include&gt;</tt> and <tt class="sgmltag-element">&lt;xsl:import&gt;</tt>.
Of the two, <tt class="sgmltag-element">&lt;xsl:include&gt;</tt> is
the simpler. It treats the included content as if it were
actually typed into the file at that point, and doesn't
give it any more or less precedence relative to the
surrounding text. It is best used when assembling
dissimilar templates that don't overlap what they match.
The DocBook driver files use this instruction to assemble a
set of modules into a stylesheet.</p><p>In contrast, <tt class="sgmltag-element">&lt;xsl:import&gt;</tt> lets
you manage the precedence of templates and variables. It is
the preferred mode of customizing another stylesheet because
it lets you override definitions in the distributed
stylesheet with your own, without altering the distribution
files at all. You simply import the whole stylesheet and
add whatever changes you want.</p><p>The precedence rules for import are detailed and
rigorously defined in the XSL standard. The basic rule is
that any templates and variables in the importing
stylesheet have precedence over equivalent templates and
variables in the imported stylesheet. Think of the imported stylesheet elements as a fallback collection, to be used only if a match is not found in the current stylesheet. You can customize the templates you want to change in your stylesheet file, and let the imported stylesheet handle the rest.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Customizing a DocBook XSL stylesheet is the opposite
of customizing a DocBook DTD. When you customize a DocBook
DTD, the rules of <span class="acronym">XML</span> and <span class="acronym">SGML</span> dictate that
the <span class="emphasis"><em>first</em></span> of any duplicate declarations
wins. Any subsequent declarations of the same element or
entity are ignored. The architecture of the DTD provides
slots for inserting your own custom declarations early
enough in the DTD for them to override the standard
declarations. In contrast, customizing an XSL stylesheet is
simpler because your definitions have precedence over imported ones.</p></div><p>You can carry modularization to deeper levels because
module files can also include or import other modules.
You'll need to be careful to maintain the precedence that
you want as the modules get rolled up into a complete
stylesheet. </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e13119"></a>Customizing
with <tt class="sgmltag-element">&lt;xsl:import&gt;</tt></h4></div></div><div></div></div><p>There is currently one example of customizing
with <tt class="sgmltag-element">&lt;xsl:import&gt;</tt> in the HTML
version of the DocBook stylesheets.
The <tt class="filename">xtchunk.xsl</tt> stylesheet modifies the
HTML processing to output many smaller HTML files rather
than a single large file per input document. It uses XSL
extensions defined only in the XSL
processor <span><b class="command">XT</b></span>. In the driver
file <tt class="filename">xtchunk.xsl</tt>, the first instruction
is <tt class="sgmltag-element">&lt;xsl:import
href="docbook.xsl"/&gt;</tt>. That instruction imports
the original driver file, which in turn uses
many <tt class="sgmltag-element">&lt;xsl:include&gt;</tt> instructions to
include all the modules. That single import instruction
gives the new stylesheet the complete set of DocBook
templates to start with.</p><p>After the
import, <tt class="filename">xtchunk.xsl</tt> redefines some of
the templates and adds some new ones. Here is one example
of a redefined template:</p><pre class="programlisting"><i class="lineannotation"><span class="lineannotation">Original template in autotoc.xsl</span></i>
&lt;xsl:template name="href.target"&gt;
  &lt;xsl:param name="object" select="."/&gt;
  &lt;xsl:text&gt;#&lt;/xsl:text&gt;
  &lt;xsl:call-template name="object.id"&gt;
    &lt;xsl:with-param name="object" select="$object"/&gt;
  &lt;/xsl:call-template&gt;
&lt;/xsl:template&gt;

<i class="lineannotation"><span class="lineannotation">New template in xtchunk.xsl</span></i>
&lt;xsl:template name="href.target"&gt;
  &lt;xsl:param name="object" select="."/&gt;
  &lt;xsl:variable name="ischunk"&gt;
    &lt;xsl:call-template name="chunk"&gt;
      &lt;xsl:with-param name="node" select="$object"/&gt;
    &lt;/xsl:call-template&gt;
  &lt;/xsl:variable&gt;

  &lt;xsl:apply-templates mode="chunk-filename" select="$object"/&gt;

  &lt;xsl:if test="$ischunk='0'"&gt;
    &lt;xsl:text&gt;#&lt;/xsl:text&gt;
    &lt;xsl:call-template name="object.id"&gt;
      &lt;xsl:with-param name="object" select="$object"/&gt;
    &lt;/xsl:call-template&gt;
  &lt;/xsl:if&gt;
&lt;/xsl:template&gt;
</pre><p>The new template handles the more complex processing
of HREFs when the output is split into many HTML files.
Where the old template could simply
output <tt class="literal">#<i class="replaceable"><tt>object.id</tt></i></tt>,
the new one outputs <tt class="literal"><i class="replaceable"><tt>filename</tt></i>#<i class="replaceable"><tt>object.id</tt></i></tt>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e13170"></a>Setting stylesheet variables</h4></div></div><div></div></div><p>You may not have to define any new templates,
however. The DocBook stylesheets are parameterized using
XSL variables rather than hard-coded values for many of the
formatting features. Since
the <tt class="sgmltag-element">&lt;xsl:import&gt;</tt> mechanism also
lets you redefine global variables, this gives you an easy
way to customize many features of the DocBook
stylesheets. Over time, more features will be parameterized to permit customization. If you find hardcoded values in the stylesheets that would be useful to customize, please let the maintainer know.</p><p>Near the end of the list of includes in the main
DocBook driver file is the
instruction <tt class="sgmltag-element">&lt;xsl:include
href="param.xsl"/&gt;</tt>.
The <tt class="filename">param.xsl</tt> file is the most
important module for customizing a DocBook XSL stylesheet.
This module contains no templates, only definitions of
stylesheet variables. Since these variables are defined
outside of any template, they are global variables and
apply to the entire stylesheet. By redefining these
variables in an importing stylesheet, you can change the
behavior of the stylesheet.</p><p>To create a customized DocBook stylesheet, you simply
create a new stylesheet file such
as <tt class="filename">mystyle.xsl</tt> that imports the standard
stylesheet and adds your own new variable definitions. Here
is an example of a complete custom stylesheet that changes
the depth of sections listed in the table of contents from
two to three:</p><pre class="programlisting">&lt;?xml version='1.0'?&gt;
&lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                version='1.0'
                xmlns="http://www.w3.org/TR/xhtml1/transitional"
                exclude-result-prefixes="#default"&gt;

&lt;xsl:import href="docbook.xsl"/&gt;

&lt;xsl:variable name="toc.section.depth"&gt;3&lt;/xsl:variable&gt;
&lt;!-- Add other variable definitions here --&gt;

&lt;/xsl:stylesheet&gt;
</pre><p>Following the opening stylesheet element are the
import instruction and one variable definition. The
variable <tt class="varname">toc.section.depth</tt> was defined
in <tt class="filename">param.xsl</tt> with value "2", and here
it is defined as "3". Since the importing stylesheet takes
precedence, this new value is used. Thus documents
processed with <tt class="filename">mystyle.xsl</tt> instead
of <tt class="filename">docbook.xsl</tt> will have three levels
of sections in the tables of contents, and all other
processing will be the same.</p><p>Use the list of variables
in <tt class="filename">param.xsl</tt> as your guide for creating
a custom stylesheet. If the changes you want are controlled
by a variable there, then customizing is easy. </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e13212"></a>Writing your own templates</h4></div></div><div></div></div><p>If the changes you want are more extensive than what
is supported by variables, you can write new templates. You
can put your new templates directly in your importing
stylesheet, or you can modularize your importing stylesheet
as well. You can write your own stylesheet module
containing a collection of templates for processing lists,
for example, and put them in a file
named <tt class="filename">mylists.xsl</tt>. Then your importing
stylesheet can pull in your list templates with
a <tt class="sgmltag-element">&lt;xsl:include
href="mylists.xsl"/&gt;</tt> instruction. Since your
included template definitions appear after the main import
instruction, your templates will take precedence.</p><p>You'll need to make sure your new templates are
compatible with the remaining modules, which means:</p><div class="itemizedlist"><ul type="disc"><li><p>Any named templates should use the same name so
calling templates in other modules can find them.</p></li><li><p>Your template set should process the same elements
matched by templates in the original module, to ensure
complete coverage.</p></li><li><p>Include the same set
of <tt class="sgmltag-element">&lt;xsl:param&gt;</tt> elements in each
template to interface properly with any calling templates,
although you can set different values for your
parameters.</p></li><li><p>Any templates that are used like subroutines to
return a value should return the same data type.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e13241"></a>Writing your own driver</h4></div></div><div></div></div><p>Another approach to customizing the stylesheets is to
write your own driver file. Instead of
using <tt class="sgmltag-element">&lt;xsl:import
href="docbook.xsl"/&gt;</tt>, you copy that file to a
new name and rewrite any of
the <tt class="sgmltag-element">&lt;xsl:include/&gt;</tt> instructions to
assemble a custom collection of stylesheet modules. One
reason to do this is to speed up processing by reducing the
size of the stylesheet. If you are using a customized
DocBook DTD that omits many elements you never use, you
might be able to omit those modules of the
stylesheet.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e13252"></a>Localization</h4></div></div><div></div></div><p>The DocBook stylesheets include features for
localizing generated text, that is, printing any generated
text in a language other than the default English. In
general, the stylesheets will switch to the language
identified by a <tt class="sgmltag-attribute">lang</tt> attribute when
processing elements in your documents. If your documents
use the <tt class="sgmltag-attribute">lang</tt> attribute, then you don't
need to customize the stylesheets at all for
localization.</p><p>As far as the stylesheets go,
a <tt class="sgmltag-attribute">lang</tt> attribute is inherited by the
descendents of a document element. The stylesheet searches
for a <tt class="sgmltag-attribute">lang</tt> attribute using this XPath
expression:</p><pre class="programlisting">&lt;xsl:variable name="lang-attr"
         select="($target/ancestor-or-self::*/@lang
                  |$target/ancestor-or-self::*/@xml:lang)[last()]"/&gt;</pre><p>This locates the attribute on the current element or
its most recent ancestor. Thus
a <tt class="sgmltag-attribute">lang</tt> attribute is in effect for an
element and all of its descendents, unless it is reset in
one of those descendents. If you define it in only your
document root element, then it applies to the whole
document:</p><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.0//EN" "docbook.dtd"&gt;
&lt;book lang="fr"&gt;
...
&lt;/book&gt;</pre><p>When text is being generated, the stylesheet checks
the most recent <tt class="sgmltag-attribute">lang</tt> attribute and looks
up the generated text strings for that language in a
localization <span class="acronym">XML</span> file. These are located in
the <tt class="filename">common</tt> directory of the
stylesheets, one file per language. Here is the top of the
file <tt class="filename">fr.xml</tt>:</p><pre class="programlisting">&lt;localization language="fr"&gt;

&lt;gentext key="abstract"                 text="R&amp;#x00E9;sum&amp;#x00E9;"/&gt;
&lt;gentext key="answer"                   text="R:"/&gt;
&lt;gentext key="appendix"                 text="Annexe"/&gt;
&lt;gentext key="article"                  text="Article"/&gt;
&lt;gentext key="bibliography"             text="Bibliographie"/&gt;
...
</pre><p>The stylesheet templates use the gentext key names,
and then the stylesheet looks up the associated text value
when the document is processed with that lang setting. The
file <tt class="filename">l10n.xml</tt> (note
the <tt class="filename">.xml</tt> suffix) lists the filenames of
all the supported languages.</p><p>You can also create a custom stylesheet that sets the
language. That might be useful if your documents don't make
appropriate use of the <tt class="sgmltag-attribute">lang</tt> attribute.
The module <tt class="filename">l10n.xsl</tt> defines two global
variables that can be overridden with an importing
stylesheet as described above. Here are their default
definitions:</p><pre class="programlisting">&lt;xsl:variable name="l10n.gentext.language"&gt;&lt;/xsl:variable&gt;
&lt;xsl:variable name="l10n.gentext.default.language"&gt;en&lt;/xsl:variable&gt;
</pre><p>The first one sets the language for all elements,
regardless of an element's <tt class="sgmltag-attribute">lang</tt> attribute
value. The second just sets a default language for any
elements that haven't got a <tt class="sgmltag-attribute">lang</tt> setting
of their own (or their ancestors).</p></div></div></div><div class="footnotes"><br><hr width="100" align="left"><div class="footnote"><p><sup>[<a name="ftn.d0e9262" href="#d0e9262">14</a>] </sup>
See <i class="citetitle"><a href="http://www-cals.itsi.disa.mil/core/formal/fps.htm" target="_top">Formally
Published CALS Standards</a></i> for more information.
</p></div><div class="footnote"><p><sup>[<a name="ftn.d0e11537" href="#d0e11537">15</a>] </sup>
Language codes should conform to <span class="acronym">IETF</span>
<span class="acronym">RFC</span> 3066.
</p></div><div class="footnote"><p><sup>[<a name="ftn.d0e12138" href="#d0e12138">16</a>] </sup>
The use of uppercase names here is intentional. These are not
attributes that an author is ever expected to type. In <span class="acronym">XML</span>, which is
case-sensitive, using uppercase for things like this reduces the
likelihood of collision with &#8220;<span class="quote">real</span>&#8221; attribute names in the
<span class="acronym">DTD</span>.
</p></div><div class="footnote"><p><sup>[<a name="ftn.d0e12845" href="#d0e12845">17</a>] </sup>Technically, the scope extends to the end tag of the parent of the <tt class="sgmltag-element">&lt;xsl:variable&gt;</tt> element. That is effectively the last sibling.</p></div></div></div><div class="navfooter"><table width="100%" summary="Navigation table"><tr><td width="40%" align="left"><a title="Parsing DocBook Documents" href="ch03.html"><img src="figures/nav-prev.png" alt="Prev" border="0"></a>&nbsp;</td><td width="20%" align="center"><a title="DocBook" href="docbook.html"><img src="figures/nav-home.png" alt="Home" border="0"></a></td><td width="40%" align="right">&nbsp;<a title="Customizing DocBook" href="ch05.html"><img src="figures/nav-next.png" alt="Next" border="0"></a></td></tr><tr><td width="40%" align="left">Parsing DocBook Documents&nbsp;</td><td width="20%" align="center"><a title="Part&nbsp;I.&nbsp;Introduction" href="part1.html"><img src="figures/nav-up.png" alt="Up" border="0"></a></td><td width="40%" align="right">&nbsp;Customizing DocBook</td></tr></table></div><div class="copyrightfooter"><p><a href="dbcpyright.html">Copyright</a> &copy; 1999, 2000, 2001, 2002 <a href="http://www.oreilly.com/">O'Reilly &amp; Associates, Inc.</a> All rights reserved.</p></div></body></html>